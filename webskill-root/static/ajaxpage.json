{"success":true,"data":[{"id":"5a2403226190c8912ebaceeb","author_id":"4f447c2f0a8abae26e01b27d","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"//dn-cnode.qbox.me/FhSNYCv6Ab9wzT6aUSfKLa0GtP4w\" alt=\"image.png\"></p>\n<blockquote>\n<p>原文地址：知乎专栏 <a href=\"https://zhuanlan.zhihu.com/p/31640541\">https://zhuanlan.zhihu.com/p/31640541</a></p>\n</blockquote>\n<p>给大家介绍下，Egg 2.0 正式版，今天 12.3 冒泡啦，距 3.21 的 <a href=\"https://zhuanlan.zhihu.com/p/25860846\">Egg 1.0 版本</a> 时隔 8 个月。</p>\n<p><img src=\"//dn-cnode.qbox.me/FrC_ZbrhyLkhVIquPOsMqPhvqsHX\" alt=\"image.png\"></p>\n<blockquote>\n<p><a href=\"https://eggjs.org/\">Egg</a> 是阿里 Node.js 的核心基础框架，面向『企业级的 Web 基础框架』这个领域，提供了「微内核 + 插件机制 + 框架定制能力」，完美达成生态共建和差异化定制的平衡点。<br>\n既适合个人小项目快速开发，也适合团队架构师基于自身的技术架构在 Egg 基础上扩展出适合特定团队业务场景的框架。<br>\n它沉淀自阿里在各行各业不同领域的大规模工程实践经验，稳定支撑了多年天猫双11大促，顶级流量压力。</p>\n</blockquote>\n<h2>2.0 特性</h2>\n<ul>\n<li>基于 Koa 2.x\n<ul>\n<li>异步解决方案直接基于 Async Function 。</li>\n<li>去除 co 兼容后<a href=\"https://github.com/eggjs/egg/wiki/co-vs-async\">堆栈信息更清晰</a>。</li>\n</ul>\n</li>\n<li>框架层优化带来 <a href=\"https://eggjs.github.io/benchmark/plot/\">30% 左右的性能提升</a>，不含 Node 8 带来的提升。</li>\n<li>为了方便开发者快速升级，保持了对 Egg 1.x 以及 generator function 的兼容。</li>\n</ul>\n<p><img src=\"//dn-cnode.qbox.me/Fuf5DkXMxM7wfClcN6B6LzX5d18Q\" alt=\"image.png\"></p>\n<h2>如何升级</h2>\n<p><strong><a href=\"https://eggjs.org/\">Egg</a> 的理念之一是渐进式增强，故我们为开发者提供渐进升级的体验。</strong></p>\n<ol>\n<li>Node.js 使用最新的 LTS 版本（&gt;=8.9.0）。</li>\n<li>修改 package.json 中 egg 的依赖为 ^2.0.0。</li>\n<li>检查相关插件是否发布新版本（可选）。</li>\n<li>重新安装依赖，跑单元测试。</li>\n</ol>\n<p><strong>搞定！几乎不需要修改任何一行代码，就已经完成了升级。</strong></p>\n<p>这得益于 Egg 对 1.x 的兼容，但为了更好的统一代码风格，以及更佳的性能和错误堆栈，我们建议开发者参考 <a href=\"https://eggjs.org/zh-cn/migration.html\">升级指南</a> 进一步升级。</p>\n<h2>未来规划</h2>\n<p>如您所知，Egg 采用的是 <strong>『微内核 + 插件 + 上层框架』</strong> 模式。</p>\n<p>其中微内核经过 3 年 4 个版本，以及在阿里的大规模应用，已经打磨的非常稳定。</p>\n<p>接下来我们的<strong>重心主要在开发者体验方面的优化</strong>，包括：</p>\n<ul>\n<li>更好的开发者体验，包括 TypeScript，开发者工具，IDE 工具等方面。</li>\n<li>社区扶持\n<ul>\n<li>协助业界的前端团队，打造适合特定团队业务场景的上层框架，欢迎勾搭。</li>\n<li>分享我们在团队、协作、规范化等方面的经验。</li>\n<li>分享在 Docker，GraphQL，SSR 等方面的探索和最佳实践分享。</li>\n</ul>\n</li>\n<li>国际化，官网和<a href=\"https://github.com/eggjs/egg/issues/363\">文档翻译</a>等。</li>\n</ul>\n<p>同时，我们也欢迎社区更多的<a href=\"https://github.com/orgs/eggjs/projects\">参与</a>，一起打造更完善的生态。</p>\n<p><img src=\"//dn-cnode.qbox.me/Fg_WHGNC13j2azgEWb-ONk5whle5\" alt=\"image.png\"></p>\n<h2>我们这一年</h2>\n<p>截止至今天(2017-12-03)：</p>\n<ul>\n<li><strong>GitHub 5.6k star</strong>，555 forks，npm 月下载量 11,140 (不含阿里内网数据)。</li>\n<li>从 1.0 到 2.0，我们一共发布了 <a href=\"https://github.com/eggjs/egg/releases\">18 个版本</a>，处理了 820 个 issue，收到了 500+ (主库 272) 个 Pull Request 。</li>\n<li>开发者体验方面的优化包括：<a href=\"https://eggjs.org/zh-cn/core/development.html#%E4%BD%BF%E7%94%A8-egg-bin-%E8%B0%83%E8%AF%95\">断点调试代理</a>，<a href=\"https://eggjs.org/zh-cn/core/development.html#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95\">单元测试+覆盖率</a>，<a href=\"https://eggjs.org/zh-cn/core/deployment.html#%E9%83%A8%E7%BD%B2\">部署工具</a>，TypeScript 支持，<a href=\"https://github.com/eggjs/vscode-eggjs\">VSCode 插件</a>，文档优化等等。</li>\n</ul>\n<p><strong>社区方面：</strong></p>\n<ul>\n<li>来自 BAT，丁香园，全民直播等多家兄弟公司的反馈和插件回馈。</li>\n<li>来自 <a href=\"https://github.com/eggjs/egg/network/dependents\">GitHub Dependents</a> 的统计：992 Repositories, 231 Packages</li>\n<li><a href=\"https://npms.io/search?q=egg-\">NPM 搜索结果</a>超过 400 个。</li>\n<li>上层框架：\n<ul>\n<li><a href=\"https://github.com/alibaba/beidou\">北斗</a> - Isomorphic framework for server-rendered React apps</li>\n<li><a href=\"https://github.com/avetjs/avet\">avet</a> - A very comfortable framework for writing isomorphic applications</li>\n</ul>\n</li>\n<li>如果你有好的分享，PR 传送门：<a href=\"https://github.com/eggjs/awesome-egg\">awesome-egg</a></li>\n</ul>\n<p><strong>趣味数据：</strong></p>\n<ul>\n<li>官网访问量中，Mac 占 47% → 这比例挺高的，看来 Node 程序猿都很幸福。</li>\n<li>周末的访问量约为平时的 1/3 → 看来 Node 程序猿周末加班少。（滑稽</li>\n<li>官网访问来源：站内，直链，外链各 30% 多，来自搜索引擎的较少。</li>\n</ul>\n<p><strong>分享交流：</strong></p>\n<ul>\n<li>在 <a href=\"http://2017.jsdc.tw/\">台灣 JSDC2017 開發者年會</a> 和 <a href=\"http://2017.imweb.io/index.html#schedule\">腾讯IMWebConf</a> 分享了『<a href=\"https://github.com/atian25/blog/raw/master/assets/files/Egg%20%26%20Node.js%20%E4%BB%8E%E5%B0%8F%E5%B7%A5%E5%9D%8A%E8%B5%B0%E5%90%91%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%BC%80%E5%8F%91.pdf\">Egg &amp; Node.js 从小工坊走向企业级开发</a>』</li>\n</ul>\n<p><img src=\"//dn-cnode.qbox.me/FgFUrGpNw07LKQPYzGgZp64j7CZH\" alt=\"image.png\"></p>\n<ul>\n<li>Node TSC @张秋怡 在 <a href=\"https://nina17.sched.com/event/Atii/nodejs-at-alibaba-a-joyee-cheung-alibaba-cloud\">Node Interactive North America 2017</a> 和 <a href=\"http://nodefest.jp/2017/schedule.html#joyee\">東京Node学園祭2017</a> 分享了『<a href=\"https://github.com/joyeecheung/talks/blob/master/node_fest_2017/nodejs_at_alibaba_tokyo.pdf\">Node.js at Alibaba</a>』。</li>\n</ul>\n<p><img src=\"//dn-cnode.qbox.me/Fl5IyrfAMzQ49Uz3eQ67i2FLL09H\" alt=\"image.png\"></p>\n<ul>\n<li><a href=\"/user/ngot\">@ngot</a> 在 <a href=\"https://www.bagevent.com/event/751307\">Node Party</a> 分享了『<a href=\"https://github.com/Hangzhou-Node-Party/Node-Party/blob/master/2017-08-19/Egg.js%E5%9C%A8%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E9%9B%86%E5%9B%A2%E7%9A%84%E7%9A%84%E5%AE%9E%E8%B7%B5%E8%BF%90%E7%94%A8.pdf\">Egg.js 在阿里巴巴集团的实践运用</a>』</li>\n<li>@姜天意 在 <a href=\"http://2017.imweb.io/index.html#schedule\">腾讯IMWebConf</a> 分享了 『<a href=\"https://github.com/jtyjty99999/share/blob/master/security%20risk%20in%20node%20web.pdf\">脆弱的 Node.js</a>』</li>\n</ul>\n<h2>写在最后</h2>\n<p>开源，痛并快乐着。</p>\n<p><img src=\"//dn-cnode.qbox.me/Fiamh5LNYR3e2E0HtdhrO3sVfHrs\" alt=\"image.png\"></p>\n</div>","title":"企业级 Node.js 框架 Egg 发布 2.0，性能提升 30%，拥抱 Async","last_reply_at":"2018-01-18T07:05:58.752Z","good":true,"top":true,"reply_count":96,"visit_count":14669,"create_at":"2017-12-03T13:58:58.901Z","author":{"loginname":"atian25","avatar_url":"https://avatars1.githubusercontent.com/u/227713?v=3&s=120"}},{"id":"5a54a8a4afa0a121784a8ab0","author_id":"54009f5ccd66f2eb37190485","tab":"share","content":"<div class=\"markdown-text\"><p>很抱歉在首届蚂蚁体验科技 SEE Conf 大会上，给大家讲得有点磕绊不太清楚。今天写下来行诸文字，希望一些思考能与大家进一步交流。（设计师朋友可以跳过前端技术部分，直接看后面章节）</p>\n<h2>什么是前端技术</h2>\n<p>第一次接触前端开发是 2002 年大学期间，转眼 15 年多。这些年一直在思考一个问题：究竟什么是前端技术？很长很长一段时间，前端技术的定义非常清晰，就是浏览器端的 HTML、CSS、JS 技术。我们用这些技术做出各种各样的页面，我们是离用户最近的程序员。</p>\n<p><img src=\"//dn-cnode.qbox.me/FuTZzCUKkL_OGOsmrXbXvcqalO-D\" alt=\"v2-356e4bb976792ec0c2ae166405e4b502_hd.jpg\"></p>\n<p>记得 2009 年开始接触 Node，很快前端技术开始爆炸性增长。最开始的变化，是前端压缩工具从基于 Java 的 YUI Compressor 开始切换到基于 Node 实现的 UglifyJS 等工具。除了前端工具上的一路狂奔，在服务端领域也出现了 Express 等框架，前端开始通过 Node 完成服务端模板甚至整个 MVC 层的开发。在蚂蚁金服，服务端层我们更多把 Node 定位为 BFF 层实现，BFF 是 Backend For Frontend 的缩写，翻译成用户体验适配层。</p>\n<p>BFF 模式下，整体分工很清晰，后端通过 Java 等语言负责服务实现，理想情况下给前端提供的是基于领域模型的 RPC 接口，前端则在 BFF 层直接调用服务端 RPC 接口拿到数据，按需加工消费数据，并实现人机交互。基于 BFF 模式的研发，很适合拥有前端技术背景的全栈型工程师。这种模式的好处很明显，后端可以专注于业务领域，更多从领域模型的视角去思考问题，页面视角的数据则交给前端型全栈工程师去搞定。领域模型与页面数据是两种思维模式，通过 BFF 可以很好地解耦开，让彼此更专业高效。</p>\n<p>除了服务端的渗透，从 2013 年开始，阿里开始无线 ALL IN 战略，这对前端影响非常大。有相当多的前端开始转型为 iOS 工程师（转型为 Android 的比较少，有部分 Java 工程师转型成了 Android 开发），没有转型的，也开始大量投入到 Mobile Web 开发。这个大背景下，前端与客户端技术开始互相融合，特别是在容器层。从 2015 年开始，物联网 IoT 逐步兴起，前端开始涉足 IoT 设备上的应用研发。端的本质是 devices，台式机、手机、IoT 设备都是一台台 devices，很多会直接被用户使用，有用户使用的 devices，就会有人机交互需求，就会有前端的工作价值。前端是离用户最近的工程师，这个定位一直没变。</p>\n<p>非常有意思的是，在移动端的架构里，这几年也出现了基于 RPC 接口 + 网关 + BFF 的架构体系，在研发效率、网络性能等方面均有优势。随着 IoT 应用的涌现与复杂化，我相信最终也会出现 BFF 架构。BFF 模式不仅仅是一种技术架构，从社会分工角度讲，BFF 更是一种多元价值导向的分层架构，每一层都有不错的空间去施展，不仅能发挥工业社会双手的作用，还能使用上双手上面的脑袋。齿轮不再是被动跟着转，而是开始拥有自驱的转动力。同一时期，业界也出现了一些类似的职业融合。比如 DevOps 倡导开发也懂运维，不少大公司在推行开发也懂测试，测试则转型为更专业的质量工具部门，还有前端也懂设计的 DesignOps 的出现等等。各种全栈概念的涌现，都是在重新探索更合理的分层协作模式。纷纷扰扰，成败如风。</p>\n<p>补充一个说明，当年提出的前后端分离，并不准确，这些年一直努力纠正为前后端分层的理念。专业的分工协同对效能的提升很关键。全栈的含义是指分层演化后，每一层的技术栈要求，是每一层横向技能的全，而不是纵向跨层的通（纵向跨多层都能通的人才非常少，就如当今社会已经非常难诞生博物学家了）。不断探索更好的分层协作是有意思的，这就如人类家庭里夫妻的关系一样，男权、女权都不可取，社会的演化最终会视人为人，每个个体平等、自由，社会会以一种必然的不可阻挡的形态往前演进。</p>\n<p>回到前端发展历史，前面说了这么多，只说了一件事，前后端分层协作的各种模式。协作的边界是数据，后端提供数据服务接口，前端消费数据实现人机交互。不同模式下，BaaS（Backend as a Service）的含义各有不同。在 BFF 模式下，由于 BFF 层的运维部署需要，前端还需负责 BFF 层的 PaaS 平台建设。不同模式下的工程体系各有不同，工程的本质是让一群人做好一堆事，涉及代码规范、协作流程、运维部署、性能与安全等很多领域，这里不再一一展开。</p>\n<p>服务端 Node 与各种终端的涌现，让前端进入了大前端范畴，这时候的前端，已远远不只是浏览器端的页面实现技术，而是后端服务与人机界面的连接器。</p>\n<p><img src=\"//dn-cnode.qbox.me/Fgj5HsTiql9rambFQbhDg8t49tw3\" alt=\"v2-374230208f31483237155e80d46f1c0d_hd.jpg\"></p>\n<h2>什么是体验科技</h2>\n<p>我属于无线 ALL IN 战略中，选择留下来继续做 PC Web 的前端。虽然公司重点转向无线，但 PC 业务一直没停。随着近几年整个阿里集团“大中台、小前台”的策略，越来越多的企业级中后台产品处于兵荒马乱阶段，设计师非常缺失，随手一抓，都是大量体验比较糟心的产品。这过程中，越来越感觉什么地方有问题，一定在某些点上我们没做好。当时没多想，就想着既然缺设计师，我们就尝试去招聘。于是体验技术部开始拥有了设计师，非常艰辛的起步，非常感激的是，虽然艰辛，但找到了一些与我一样坚信中后台产品价值的设计师。一旦有了设计师，整个中后台产品的用户体验，一下子就提升上来了。</p>\n<p><img src=\"//dn-cnode.qbox.me/FvNAdF0m7cCZlevYQDFThuRYxvbz\" alt=\"v2-54abf60cd133916e016343ae4adaf376_hd.jpg\"></p>\n<p>设计团队的融入，日常的各种碰撞交流，让我的思维发生了很大变化。前端技术再牛，都很难直接解决产品层的用户体验。对中后台产品来说，设计的价值也远远不止于让产品的颜值提升，设计的更多更多价值，在于深入到产品的业务逻辑里去，去帮助业务梳理产品信息架构与任务流程。用户体验是一个非常综合的事，需要各种专业人士在同一个产品上聚焦发力，一起共同努力才能真正提升产品体验。设计师在这个过程中很痛苦，很多中后台产品都是非常垂直领域的业务产品，中间件、ECS、ODPS 等一堆堆专业术语让设计师们痛苦不堪，幸运的是，我们扛了过来。</p>\n<p><img src=\"//dn-cnode.qbox.me/Fk5n__QHurYmZawYh6-UXJ5Ox0Tv\" alt=\"v2-9b693a1affab86f96e24e0bee03b3e90_hd.jpg\"></p>\n<p>接下来的故事，在今天各个讲师的分享里，不少都有提及。整个团队的重心，开始非常清晰地往几个方向发展：</p>\n<ul>\n<li>TWA 方向：这是比 BFF 更大的概念，上午不四的分享里有详细阐述，可参考 知乎专栏文章 。TWA 是 Techless Web App 的缩写，是一种技术理念，希望越来越多的开发者，可以不用再关注流程、构建、环境、部署等各种事，希望能做到技术无感化（Techless），让每一位开发着能安安静静的快乐编码。</li>\n<li>UI 智能化方向：Ant Design 是一个设计体系，antd 是 Ant Design 的 React 实现。这几年 antd 的发展，不仅让前端编码更快更爽了，同时让一个历史悠久但生生不息的领域重燃希望：是否存在人机交互界面智能可视化搭建的可能？这个领域，这一两年在阿里内部非常火，各种搭建产品层出不穷，目前都还处于比较垂直的领域，泛化到行业级通用的产品还没怎么出现。我们也开始尝试，而且我们相信天时地利人和，一定能折腾出点什么，正在努力中，或许在下次 SEE Conf 大会中会展示给大家。</li>\n<li>数据可视化方向：下午绝云和御术的分享，相信大家对 G2 和 AntV 已经有了一个整体了解。可视化方向我们是从 2014 年开始正式投入人员去做，最开始的想法来自科幻片，大家如果喜欢看科幻片的话，会留意到各种人机交互界面都是各种可视化效果了，很少很少有传统网页。可视化是个历史非常悠久的领域，我们小学时学会的乘法竖式，就是一种可视化，可以帮助我们减少记忆成本，同时提升计算速度。</li>\n<li>图形互动化方向： 上午好修和景夫有分享，这一块才开始一年多，是我们非常笃定的一个方向。很多小孩，对书本都比较抗拒，但对游戏有着天生的喜爱。蚂蚁森林让大家从表单形式的公益，变成了互动游戏型的公益。越来越多的人机交互形式，会是有互动交互的图形界面。应用的泛互动化，是一个很大趋势。支付宝是个生活服务平台，各种生活服务的互动有趣化，一定是更有吸引力的。</li>\n</ul>\n<p><img src=\"//dn-cnode.qbox.me/Fui53ymFhJc0JS0IA0ZXqUvBNFiQ\" alt=\"v2-6830ebf2ca603dca8bd33723d73220e3_hd.jpg\"></p>\n<p>看更远的未来，我相信对体验科技来说，自然化和虚拟化会是两个大趋势。</p>\n<p>我现在在分享这个 PPT，要翻页时，需要点击键盘按钮，为什么电脑不能直接理解我的意图而自动翻页呢？比如我只要头往下示意一下，就能自然而然翻到下一页。我们现在很多行为，跳脱出来看，能发现很多很多不自然。天猫精灵等各种智能音箱，真正去用时，离自然交互还有比较远的距离。Ant Design 设计价值观里，最最重要的就是自然价值观，一切才刚刚开始探索。</p>\n<p>再说虚拟化。虚拟化不仅仅指 AR、VR 等技术，看过黑客帝国、西部世界等科幻片的，会对虚拟化有更多体感。如果以后每个小孩出生时，就会被植入一个能五感俱全的芯片，这种情况下，我们的人机交互会是怎么样的。太多可能性与挑战在等着我们。</p>\n<p>这一切都是体验科技，是技术与设计的融合，是服务与用户连接，是下图中的一个公式。</p>\n<p><img src=\"//dn-cnode.qbox.me/Fh5rgc3RVIRYuQYZSXMdKlBKlfnB\" alt=\"v2-773def061a6dd38cd97c52f040da29cc_hd.jpg\"></p>\n<p><img src=\"//dn-cnode.qbox.me/FpueJ6H7sBiB7kVsLORMYQpjDClK\" alt=\"v2-e4186cd37a1f978abbf64970dee50ba9_hd.jpg\"></p>\n<p>体验科技是 UX = f(services) 这个公式，能将各种各种的 services（后端服务） 通过技术与设计的融合，转变成体验一流的用户产品。这个公式的一个实现，就是蚂蚁体验云。蚂蚁体验云的初心，是希望能帮助有梦想的你，将一个个优秀的想法，通过体验云实现成一个个终端产品。\n<img src=\"//dn-cnode.qbox.me/FjtnnNqNeyh5rH4MTreunWUgsNgj\" alt=\"v2-ab3eae986630f436d1c6b751f4a8d895_hd.jpg\"></p>\n<p>体验云才刚刚起步，目前已在内部服务蚂蚁金服、阿里巴巴集团，同时快速孵化出了云凤蝶、语雀、小钱袋等创新产品。虽然还很不完善，但我们希望能尽快与用户一起成长。很多激动人心的事正在发生，通过体验科技的开放，我们希望着能为世界带来更多平等的机会。\n<img src=\"//dn-cnode.qbox.me/FgGx0MFi9k0eJAeLX3icMz6YLD9v\" alt=\"v2-98323a7d1c563df55151451066a7709e_hd.jpg\"></p>\n<p>感谢聆听，期待交流。</p>\n<p>附 SEE Conf 演讲视频： <a href=\"http://v.youku.com/v_show/id_XMzMwMzg2MDIwOA==.html\">优酷地址 </a></p>\n<p>最后，演讲 PPT 已精心整理并转换为 PDF 上传至<a href=\"http://yuque.com/seeconf\"> SEE Conf 语雀在线知识库</a>，欢迎下载（请 注册语雀，个人描述内注明 #知乎seeconf# 便可快速申请邀请码，登录后即可下载）</p>\n</div>","title":"玉伯《从前端技术到体验科技（附演讲视频）》","last_reply_at":"2018-01-17T14:30:58.022Z","good":false,"top":true,"reply_count":14,"visit_count":3560,"create_at":"2018-01-09T11:33:56.183Z","author":{"loginname":"i5ting","avatar_url":"https://avatars3.githubusercontent.com/u/3118295?v=4&s=120"}},{"id":"5a37c17dd92f2f5b185acfc4","author_id":"4efc278525fa69ac6900000f","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"https://dn-cnode.qbox.me/FuvPQvPz9RBxT07UrcBumIxmg-8G\" alt=\"1.png\"></p>\n<h2>大会简介</h2>\n<p>SEE = Seeking Experience &amp; Engineering，意为探索用户体验与工程实践，由蚂蚁金服集团每年举办 1-2 次，包括专业分享、产品展台、Workshop 等内容。希望通过 SEE Conf，能与业界同行一起分享交流体验科技的当前进展，一起探讨切磋体验科技的未来发展，共同努力促进体验设计与技术的开放，让生态繁荣共赢。</p>\n<p>首届 <a href=\"https://seeconf.alipay.com/\">SEE Conf</a> 将于 2018.01.06 在美丽的浙江杭州举办，届时我们将邀请数百位来自前端、设计、产品等领域的英才，围绕「极致用户体验」和「最佳工程实践」两大主题进行探讨交流。</p>\n<h2>特邀嘉宾</h2>\n<ul>\n<li>蚂蚁金服副总裁：胡喜 (阿玺)</li>\n<li>美团高级技术总监 ／ 业务负责人：刘平川 (rank)</li>\n<li>饿了么大前端部门负责人：林建锋 (sofish)</li>\n<li>百姓网资深前端架构师：贺师俊 (hax)</li>\n<li>豆瓣资深前端架构师：张克军 (kejun）</li>\n<li>钉钉资深技术专家：石玉磊 (佩玉)</li>\n<li>支付宝 UED 负责人：梁山鹰 (隼飞)</li>\n<li>蚂蚁金服体验技术部负责人：王保平 (玉伯)</li>\n</ul>\n<h2>会议日程</h2>\n<p>大会于 2018.01.06 正式召开，当天日程如下：</p>\n<ul>\n<li>09:00 - 09:15：开幕致辞</li>\n<li>09:15 - 10:00：蚂蚁中台设计体系 —— Ant Design 3.0 背后的故事</li>\n<li>10:00 - 10:45：Developer Experience First —— TWA 的理念与实践</li>\n<li>10:45 - 11:30：惊艳的互联网互动体验 —— AntG</li>\n<li>11:30 - 13:30：午间休息</li>\n<li>13:30 - 14:15：TECH 模型：企业级中后台产品体验度量探索</li>\n<li>14:15 - 15:00：AntV，返璞归真幻化万千可视化表达</li>\n<li>15:00 - 15:45：蚂蚁开发者工具，服务蚂蚁生态的移动研发 IDE</li>\n<li>15:45 - 16:30：轻推转型之门：Ant Design Pro 在企业级产品的探索</li>\n<li>16:30 - 16:45：从前端技术到体验科技，暨蚂蚁体验云起航</li>\n<li>16:45 - 17:15：圆桌 —— 体验科技的发展及未来</li>\n</ul>\n<h2>大会看点</h2>\n<p>这是蚂蚁金服体验科技首次对外发声，有大家熟悉的各个明星产品。有一个产品，过去 14 个月在 GitHub 的 star 数从 4k 飙升至 2w+，\n这是蚂蚁设计语言 <a href=\"https://ant.design/index-cn\">Ant Design</a>，她是在怎样的业务土壤与团队文化中成长起来的？背后有着怎样的故事？还有一个产品，刚一开源就得到世界级计算机科学家 <a href=\"https://www.cs.uic.edu/~wilkinson/\">Leland Wilkinson</a> 的肯定，这款技术产品是 <a href=\"https://github.com/antvis/g2\">G2</a>，其背后更大的蚂蚁可视化 <a href=\"https://antv.alipay.com/zh-cn/index.html\">AntV</a> 体系是本着怎样的初心在坚持前行？回顾过往，基于 Node.js 的前后端分层这几年在阿里经历了怎样的风雨？什么是 BFF（Backend For Frontend）架构？更进一步的 <strong>TWA</strong>（Techless Web App）架构是为了解决什么问题？为企业级框架和应用而生的 <a href=\"https://eggjs.org/\">Egg.js</a> 将走向何方？</p>\n<p>除此之外，还有最前沿的移动研发 IDE 技术和企业级产品体验度量的探索分享，更有未曾对外曝光，但已适配了千万机型的 Web 互动图形技术 AntG 将首度登台。从前端技术到体验科技，玉伯这位前端圈里的传奇黑侠将为我们讲述的“<strong>蚂蚁体验云</strong>”究竟是什么。</p>\n<p><img src=\"https://gw.alipayobjects.com/zos/rmsportal/ODVJIUEvmuKCwXqqJPfo.jpg\" alt></p>\n<p>技术大会不光能听到干货，还能面基好友结交各路大神。除了议程提到的众多明星嘉宾，从目前报名中已经发现数十位重量级人物，不乏知名公司的产品、设计总监，架构师，新锐公司的 CXO 和领域新秀。</p>\n<p>另外，蚂蚁金服是个藏龙卧虎的地方，有知名博主，也有知乎网红，有 Node.js、Ruby 等各个技术社区的大拿，还有仙剑主程、艺术插画大师，图形图像、数据可视化专家也会出没会场，有的还当起了会场志愿者在门口热切地期待着你的到来。他们会游走在会场与各个展台之间，也许就坐在你身边，这是面基好友结交大神的好时候，机会难得。</p>\n<p><img src=\"https://gw.alipayobjects.com/zos/rmsportal/DdjWkCAawyOMhFnLpGLK.jpg\" alt></p>\n<h2>如何报名</h2>\n<p>访问 <a href=\"https://seeconf.alipay.com/\">SEE Conf · 蚂蚁金服体验科技大会</a>，点击「立即报名」按钮</p>\n<p>支付宝扫描下方二维码</p>\n<p><img src=\"https://gw.alipayobjects.com/zos/rmsportal/gmcvvumwUehXYbTPBPno.gif\" alt></p>\n</div>","title":"首届蚂蚁金服体验科技大会","last_reply_at":"2018-01-05T09:47:27.966Z","good":false,"top":true,"reply_count":34,"visit_count":6960,"create_at":"2017-12-18T13:24:13.334Z","author":{"loginname":"fengmk2","avatar_url":"https://avatars0.githubusercontent.com/u/156269?v=4&s=120"}},{"id":"592917b59e32cc84569a7458","author_id":"54009f5ccd66f2eb37190485","tab":"share","content":"<div class=\"markdown-text\"><p>本来提供开发api，目的是为了开发第三方应用或客户端，如果大家用来学习也是好的，但现在很多人太过分了，随意发帖，at，严重影响了社区的用户，故而决定开始严查</p>\n<p>以下情况，直接封号</p>\n<ul>\n<li>测试标题</li>\n<li>无任何内容</li>\n<li>无意义回复</li>\n<li>测试帖，5分钟内没有删除</li>\n</ul>\n<p>欢迎大家监督</p>\n<p>封号</p>\n<ul>\n<li><a href=\"https://cnodejs.org/user/Mwangzhi\">https://cnodejs.org/user/Mwangzhi</a></li>\n<li><a href=\"https://cnodejs.org/user/lw6395\">https://cnodejs.org/user/lw6395</a></li>\n<li><a href=\"https://cnodejs.org/user/shengliang74\">https://cnodejs.org/user/shengliang74</a>  竟然挑衅，发帖说你来打我呀。。。。</li>\n<li><a href=\"https://cnodejs.org/user/h5-17\">https://cnodejs.org/user/h5-17</a> <a href=\"/user/h5-17\">@h5-17</a></li>\n<li><a href=\"https://cnodejs.org/user/592php\">https://cnodejs.org/user/592php</a> <a href=\"/user/592php\">@592php</a></li>\n</ul>\n<hr>\n<p>20170601更新</p>\n<p><a href=\"https://cnodejs.org/?tab=dev\">https://cnodejs.org/?tab=dev</a>  目前开了一个『客户端测试』专区，以后开发新客户端的同学，帖子直接发到这个专区去。tab 的值是 dev。</p>\n<p><img src=\"//dn-cnode.qbox.me/FundjyBuYk60yqQ-PdKstrPKY-7-\" alt=\"image.png\"></p>\n</div>","title":"测试请发到客户端测试专区，违规影响用户的，直接封号","last_reply_at":"2018-01-03T15:43:22.119Z","good":false,"top":true,"reply_count":147,"visit_count":36081,"create_at":"2017-05-27T06:07:49.278Z","author":{"loginname":"i5ting","avatar_url":"https://avatars3.githubusercontent.com/u/3118295?v=4&s=120"}},{"id":"5a60b106afa0a121784a8d72","author_id":"59e2bff361932717683d235e","tab":"share","content":"<div class=\"markdown-text\"><h1>electron 的一个截图插件工具</h1>\n<p><img src=\"//dn-cnode.qbox.me/FqE1dSUx8TUgFuuXM4pTE0mqScm-\" alt=\"01.png\"></p>\n<h3>测试案例</h3>\n<h4>下载之后</h4>\n<h5>$ npm i electron -g</h5>\n<h4>启动</h4>\n<h5>$ npm run dev</h5>\n<p><a href=\"https://github.com/chong0808/shotScreen\">github</a></p>\n<h3>文件结构</h3>\n<pre class=\"prettyprint\"><code>├── screen  &#x2F;&#x2F; 插件主要文件\n│   ├── mainProcess\n│   │   └── screenshot.js  &#x2F;&#x2F; 主进程引入的文件 主要是俩个渲染进程中相互通信的桥梁\n│   └── renderProcess &#x2F;&#x2F; 渲染进程引入的文件\n│       ├── asset  &#x2F;&#x2F; 资源文件\n│       ├── index.html &#x2F;&#x2F; 创建截图渲染进程的文件\n│       ├── index.js &#x2F;&#x2F;  与外界交互的操作\n│       └── main-process.js &#x2F;&#x2F;  创建截图渲染进程中 对图片剪切操作的文件 主要就是canvas的操作\n├── test  &#x2F;&#x2F; 示例文件\n│   ├── index.html \n│   └── main.js\n├── README.md\n└── package.json\n</code></pre><h3>使用方式</h3>\n<h4>下载文件之后 主进程中引入 文件</h4>\n<pre class=\"prettyprint\"><code> var screenShot = require(&#x27;.&#x2F;screen&#x2F;mainProcess&#x27;);\n &#x2F;&#x2F;主进程执行完毕之后 然后执行并传入win 实例及配置\n app.on(&#x27;ready&#x27;, () =&gt; {\n    var url = &#x27;&#x2F;index.html&#x27;;\n    win = createWindow(url);\n    win.webContents.openDevTools();\n    screenShot(win.webContents,{quit:&#x27;ctrl+shift+q&#x27;,shotKey:&#x27;ctrl+alt+d&#x27;});\n})\n</code></pre><h5>quit:退出快捷键   shotKey：截图快捷键</h5>\n<h4>渲染进程使用方式示例</h4>\n<pre class=\"prettyprint\"><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;style&gt;\n        .box {\n            width: 500px;\n            height: 200px;\n            margin: 0 auto;\n        }\n        \n        .box button {\n            width: 100px;\n            height: 30px;\n            margin: 50px;\n        }\n    &lt;&#x2F;style&gt;\n&lt;&#x2F;head&gt;\n\n&lt;body&gt;\n    &lt;div class=&quot;box&quot;&gt;\n        &lt;button data-clipScreen=&#x27;clipBtn&#x27;&gt;截图&lt;&#x2F;button&gt; &#x2F;&#x2F;在截图按钮中给与属性 data-clipScreen=&#x27;clipBtn&#x27;；或者在指定按钮绑定screen()方法\n        &lt;button data-cancelclipScreen=&#x27;clipBtn&#x27;&gt;取消&lt;&#x2F;button&gt; &#x2F;&#x2F;在截图按钮中给与属性 data-cancelclipScreen=&#x27;clipBtn&#x27;；或者在指定按钮绑定screenShot()方法\n    &lt;&#x2F;div&gt;\n&lt;&#x2F;body&gt;\n&lt;script&gt;\n    var screen = require(&#x27;.&#x2F;screen&#x2F;renderProcess&#x27;);  &#x2F;&#x2F; 引入文件\n\n&lt;&#x2F;script&gt;\n\n&lt;&#x2F;html&gt;\n</code></pre><h4>插件主进程文件</h4>\n<p>渲染进程中我们也能使用主进程中的api，在这个文件中，主要的用途就是渲染进程之间的通讯桥梁</p>\n<pre class=\"prettyprint\"><code>const { ipcMain, dialog,globalShortcut } = require(&#x27;electron&#x27;);\nmodule.exports = function(winContent,obj) {\n    &#x2F;&#x2F; 接收截图工具信号\n    ipcMain.on(&#x27;screenshot-page&#x27;, function(sender, message) {\n        switch (message.type) {\n            case &#x27;close&#x27;:\n                winContent.send(&#x27;quit-cut&#x27;)\n                break;\n            default:\n                break;\n        }\n    });\n    &#x2F;&#x2F; 退出快捷键\n    var quitShot = (obj&amp;&amp; obj.quit) || &#x27;ctrl+shift+q&#x27;;\n    var shotKey = (obj&amp;&amp; obj.shotKey) || &#x27;ctrl+alt+d&#x27;;\n\n    globalShortcut.register(quitShot, function() {\n        winContent.send(&#x27;quit-cut&#x27;, 1);\n    });\n    &#x2F;&#x2F; 截图快捷键\n    globalShortcut.register(&#x27;ctrl+alt+d&#x27;, function() {\n        winContent.send(&#x27;global-shortcut-capture&#x27;, 1);\n    });\n};\n</code></pre><h4>外部渲染进程引入的index.js</h4>\n<h5>1. 截图按钮与取消绑定方法</h5>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 点击事件绑定\ndocument.body.addEventListener(&#x27;click&#x27;, function(event) {\n    if (event.target.dataset.clipscreen) {\n        screenShot ();\n        return false;\n    }\n})\n\n&#x2F;&#x2F; 去除默认选择\ndocument.onselectstart = function() {\n    return false;\n}\n&#x2F;&#x2F; 点击事件方法\nfunction screenShot(){\n    if (!win) {\n        capturer().then(function(data) {\n            win = createChildWin(&#x27;&#x2F;index.html&#x27;, { fullscreen: true, alwaysOnTop: true, skipTaskbar: false, autoHideMenuBar: true, });\n            &#x2F;&#x2F; win.webContents.openDevTools()\n        });\n    }\n    return win;\n} \n</code></pre><h5>2.在点击之后 对屏幕进行截屏</h5>\n<pre class=\"prettyprint\"><code>&#x2F;**\n * 截取屏幕资源到本地\n *&#x2F;\nfunction capturer() {\n    return new Promise(function(resolve, reject) {\n        desktopCapturer.getSources({ types: [&#x27;window&#x27;, &#x27;screen&#x27;], thumbnailSize: { width: w, height: h } }, (error, sources) =&gt; {\n            if (error) console.error(error);\n            localStorage[&#x27;image&#x27;] = sources[0].thumbnail.toDataURL();\n            resolve(sources[0].thumbnail.toDataURL())\n        })\n    })\n}\n</code></pre><h5>3.创建渲染进程。</h5>\n<p>a.创建一个无边框全屏的渲染进程</p>\n<pre class=\"prettyprint\"><code>var opts = { \n    fullscreen: true, \n    alwaysOnTop: true, \n    skipTaskbar: false, \n    autoHideMenuBar: true \n}\n&#x2F;**\n * 创建截屏窗口\n *&#x2F;\nfunction createChildWin(_url, opts) {\n    var config = {\n        fullscreen: true,\n        frame: false\n    }\n    config = Object.assign(config, opts)\n    var _win = new BrowserWindow(config);\n    _win.loadURL(url.format({\n        pathname: path.join(__dirname + _url),\n        protocol: &#x27;file&#x27;,\n        slashes: true\n    }))\n\n    _win.on(&#x27;closed&#x27;, () =&gt; {\n        _win = null;\n    })\n    _win.on(&#x27;close&#x27;, () =&gt; {\n        _win = null;\n    })\n    return _win;\n}\n\n</code></pre><p>b.将第二步骤中截取的屏幕资源 加载到该渲染进程中的canvas中\n剩下的都是canvas截图的操作</p>\n<pre class=\"prettyprint\"><code>&#x2F;*\n *\n *原理运用遮罩层，俩个canvas，底下为背景原图产生一个黑色背景画布，上层选区，将选中像素绘制到选区\n *鼠标按下移动鼠标产生一个矩形框，\n *\n *&#x2F;\n &#x2F;&#x2F; 创建一个类\n class Screen {\n    constructor(cas, casMask, src) {\n        this.canvas = document.getElementById(cas);\n        this.canvasMask = document.getElementById(casMask);\n\n        this.context = this.canvas.getContext(&quot;2d&quot;);\n        this.contextMask = this.canvasMask.getContext(&quot;2d&quot;);\n\n        this.width = screen.width;\n        this.height = screen.height;\n        this.canvas.width = this.width;\n        this.canvas.height = this.height;\n        \n        this.image = new Image();\n        this.image.src = src;\n\n        this.cuted = false;\n        this.isShowTool = false;\n\n        this.tool = document.querySelectorAll(&#x27;.tool&#x27;)[0];\n        this.tip = document.querySelectorAll(&#x27;.tipNum&#x27;)[0];\n\n        this.leftTopCursor = document.querySelectorAll(&#x27;.left_top&#x27;)[0];\n        this.rightTopCursor = document.querySelectorAll(&#x27;.right_top&#x27;)[0];\n        this.leftBottomCursor = document.querySelectorAll(&#x27;.left_bottom&#x27;)[0];\n        this.rightBottomCursor = document.querySelectorAll(&#x27;.right_bottom&#x27;)[0];\n        &#x2F;&#x2F; 原本是将屏幕截图image画到this.context画布上的 \n        &#x2F;&#x2F;  不知道为何画出来的是空白的\n        &#x2F;&#x2F; 取而代之的方式是全屏一张图片\n        document.getElementsByTagName(&#x27;body&#x27;)[0].appendChild(this.image);\n        &#x2F;&#x2F; this.drawImg(this.image); \n        this.createMask();\n        this.getMouse();\n        &#x2F;&#x2F; 绑定this到原型链上\n        this.drawImg = this.drawImg.bind(this)\n        this.getMouse = this.getMouse.bind(this)\n        this.clearCtx = this.clearCtx.bind(this)\n        this.createRect = this.createRect.bind(this)\n        this.createMask = this.createMask.bind(this)\n        this.createReatImage = this.createReatImage.bind(this)\n        this.tipShow = this.tipShow.bind(this)\n        this.showTool = this.showTool.bind(this)\n        this.hideTool = this.hideTool.bind(this)\n        this.close = this.close.bind(this)\n        this.sendMsg = this.sendMsg.bind(this)\n        this.RGBA2ImageData = this.RGBA2ImageData.bind(this)\n        this.dragEvent = this.dragEvent.bind(this)\n    }\n</code></pre></div>","title":"基于electron 的一个截图插件工具","last_reply_at":"2018-01-18T14:36:54.247Z","good":false,"top":false,"reply_count":0,"visit_count":44,"create_at":"2018-01-18T14:36:54.247Z","author":{"loginname":"chong0808","avatar_url":"https://avatars2.githubusercontent.com/u/16454649?v=4&s=120"}},{"id":"5a60aef49d371d4a059eec29","author_id":"59588bdf545d7a7b5b0b389f","tab":"share","content":"<div class=\"markdown-text\"><p>electron本来就是个浏览器壳，所以用来做浏览器容易不过了。</p>\n<blockquote>\n<p>因为产品需要在电脑开机启动时全屏启动web app应用，加上app是vue做的，布局采用了css3的一些东西，所以对浏览器要求也高。\n之前试过chrome的kiosk模式，但是还是不够好，会带有标题栏。想来想去就拿electron来用用；然后就有了下文的Electron Browser。经过了两次版本更新，决定分享出来；喜欢的朋友可以下载玩玩。</p>\n</blockquote>\n<p>**Electron Browser **</p>\n<p>一个基于Electron开发的应用浏览器，主要用于网页APP全屏模式运行，使WEB应用看起来更像一个原生应用 浏览器主题可定制，配置简单，实现了简单的网页浏览器功能。</p>\n<p><strong>传送门</strong> <a href=\"https://www.lanyueos.com/electron-browser/#/\">Electron-browser</a></p>\n<p><strong>截图</strong>\n<img src=\"//dn-cnode.qbox.me/FjFSK0uXnzeQxP123nreQ3EBYdqs\" alt=\"20171218164524.png\"></p>\n</div>","title":"分享一款基于electron开发专为web app使用的浏览器","last_reply_at":"2018-01-18T14:28:04.229Z","good":false,"top":false,"reply_count":0,"visit_count":38,"create_at":"2018-01-18T14:28:04.229Z","author":{"loginname":"mengdu","avatar_url":"https://avatars0.githubusercontent.com/u/11366654?v=4&s=120"}},{"id":"5a609e28ce45d44045146131","author_id":"59f9da9ab381c1737d7ccb9f","tab":"ask","content":"<div class=\"markdown-text\"><p>egg-socket.io里怎么监听connect event啊😑😑</p>\n</div>","title":"egg-socket.io里怎么监听connect event啊😑😑","last_reply_at":"2018-01-18T13:16:24.648Z","good":false,"top":false,"reply_count":0,"visit_count":49,"create_at":"2018-01-18T13:16:24.648Z","author":{"loginname":"Alexerx","avatar_url":"https://avatars3.githubusercontent.com/u/22076610?v=4&s=120"}},{"id":"5a609ab0ce45d4404514612f","author_id":"5907cd62782dbc4b183ecf68","tab":"share","content":"<div class=\"markdown-text\"><p>可以在线编辑运行js代码，并且可以文件的形式存储到后台服务器。</p>\n<p>深色风格界面（装逼专用(〃‘▽’〃)）</p>\n<p><img src=\"//dn-cnode.qbox.me/Fk73YTG28L1nPoWHrmBw3kgt4aih\" alt=\"1.png\"></p>\n<p><img src=\"//dn-cnode.qbox.me/Ft-DhXztc0DfWpWnTfIVCtE3HVdd\" alt=\"2.png\"></p>\n<p>为了防止重复提交，搞了个简单的验证码–诗歌验证</p>\n<p><img src=\"//dn-cnode.qbox.me/Fp_4jneLubitf5fa51Ynw7XfeSeM\" alt=\"3.png\"></p>\n<p>项目地址：<a href=\"https://github.com/zycfj/JsBox\">https://github.com/zycfj/JsBox</a></p>\n</div>","title":"采用Vue+nodejs实现的在线Js编辑器","last_reply_at":"2018-01-18T13:01:36.965Z","good":false,"top":false,"reply_count":0,"visit_count":59,"create_at":"2018-01-18T13:01:36.965Z","author":{"loginname":"zycfj","avatar_url":"https://avatars3.githubusercontent.com/u/16100274?v=4&s=120"}},{"id":"5a5dbfa6afa0a121784a8c70","author_id":"59c3e7ade7d9a031127eadf3","tab":"share","content":"<div class=\"markdown-text\"><p>我是一个 nodejs 和 cnodejs 的忠实粉丝</p>\n<p>目前正在学习 React，就基于 React 和 antd 写了个 cnodejs 的 web 客户端作为案例</p>\n<p>api 是 cnodejs 官方的 api</p>\n<p>目前只完成了基本的文章浏览和板块的切换，还有很多工作正在进行中</p>\n<p>欢迎各位朋友体验和提意见~</p>\n<p>【地址】<a href=\"http://cnode.dzmtoast.top\">http://cnode.dzmtoast.top</a></p>\n</div>","title":"基于 React 和 antd 的 cnode web 客户端","last_reply_at":"2018-01-18T12:21:30.345Z","good":false,"top":false,"reply_count":2,"visit_count":309,"create_at":"2018-01-16T09:02:30.823Z","author":{"loginname":"toastsgithub","avatar_url":"https://avatars0.githubusercontent.com/u/11254241?v=4&s=120"}},{"id":"5a6071d5afa0a121784a8d58","author_id":"598d0f2fb98d634b1180ca59","tab":"share","content":"<div class=\"markdown-text\"><p>angular-cli 搭建环境\n根据cnode的api仿写cnode\n效果图如下：\n<img src=\"//dn-cnode.qbox.me/Fht_iJkNyHSXw07STSnB4g8n4RMH\" alt=\"20180118180243.gif\"><img src=\"//dn-cnode.qbox.me/FnMj7vfXa20EGFGTL6Kk3uJKladA\" alt=\"20180118180402.gif\"><img src=\"//dn-cnode.qbox.me/FqIfIwWB_5c4JZ59jj-8WuuUZWNK\" alt=\"20180118180405.gif\"><img src=\"//dn-cnode.qbox.me/FhEVZYFi4wJuScji5hWfdLq5eNdN\" alt=\"20180118180410.gif\"><img src=\"//dn-cnode.qbox.me/FiILJmuC3kxycmWIqWed7taoJN1s\" alt=\"20180118180419.gif\"><img src=\"//dn-cnode.qbox.me/FrVlMIxtGpQ5BSZsAkiyuO0LC1uA\" alt=\"1 (2).gif\"></p>\n<p>由于api未提供登陆接口，只是做了token验证，所以用自己账号登陆\n其中肯定存在很多问题，欢迎各位大佬指点，谢谢。\nGitHub地址：<a href=\"https://github.com/TadBO/Angular2_CNode\">https://github.com/TadBO/Angular2_CNode</a></p>\n</div>","title":"angular仿cnode","last_reply_at":"2018-01-18T11:34:08.696Z","good":false,"top":false,"reply_count":2,"visit_count":69,"create_at":"2018-01-18T10:07:17.074Z","author":{"loginname":"TadBO","avatar_url":"https://avatars3.githubusercontent.com/u/25367693?v=4&s=120"}},{"id":"5a4f232f99d207fa49f5cc42","author_id":"5a4f205ea3692d014f4f121e","tab":"share","content":"<div class=\"markdown-text\"><h1>NodeJS开挂玩微信跳一跳 不要太厉害了</h1>\n<p>github求星 求星\ngithub地址:  <a href=\"https://github.com/JesseWeb/JumpIt\">微信跳一跳自动跳跃工具</a></p>\n<h2>前言:</h2>\n<p>本脚本参照python版本去开发,内置了 ADB 环境,使用者无需安装 ADB 和配置全局变量等</p>\n<p><img src=\"//dn-cnode.qbox.me/FkIRrGfGT_M1PVnsmFSIADrEgoo_\" alt=\"67b9f1423413ef05355f857c35de5de5mini-jump.gif\"></p>\n<p>本辅助全自动执行,在意外跳跃失败结束游戏后,会自动重新开始游戏哟</p>\n<h2>使用教程</h2>\n<p>安装 <a href=\"https://www.baidu.com/link?url=9bGToaOCDpACM8CqFEVH1cMRBq8Z6nENrAVGOoPqlt3&amp;wd=&amp;eqid=a54c5cf80000d215000000065a4f1bfc\">NodeJS</a></p>\n<p>将本项目克隆到本地</p>\n<pre class=\"prettyprint\"><code>git clone https:&#x2F;&#x2F;github.com&#x2F;JesseWeb&#x2F;JumpIt.git\n</code></pre><p>进入项目根目录JumpIt Shift+右键 选择在此处打开命令窗口</p>\n<pre class=\"prettyprint\"><code> npm install\n</code></pre><p>等待包安装完毕后,把安卓手机连上电脑,打开调试模式,开发者选项中有模拟触摸选项的请一并开启</p>\n<p>进入微信打开微信跳一跳，点击开始游戏</p>\n<p>命令行输入</p>\n<pre class=\"prettyprint\"><code>npm run start\n</code></pre><p><img src=\"//dn-cnode.qbox.me/Fn3560Ob-HKvBu1021wPNm_wfMcu\" alt=\"result.jpg\"></p>\n<p>思路和原理参考 <a href=\"https://github.com/wangshub/wechat_jump_game\">https://github.com/wangshub/wechat_jump_game</a>  <a href=\"https://github.com/faceair/wechat_jump_game/blob/master/wechat_jump.py#L50\">自动跳跃算法细节参考</a></p>\n<h2>原理说明</h2>\n<ol>\n<li>用 ADB 获取手机跳一跳的截图 再用 ADB 把截图拉出来</li>\n<li>利用nodejs分析把图片解析为像素分析</li>\n<li>计算出棋子、棋盘的位置后，算出距离再乘以一个换算成时间的系数，最后转化为按压的时间</li>\n<li>再用 ADB 工具实现点击屏幕</li>\n</ol>\n<h2>移植参照:</h2>\n<p><a href=\"https://github.com/wangshub\">神奇的战士-王松</a></p>\n<p>友情链接:\n<a href=\"https://github.com/wangshub/wechat_jump_game\">教你用 Python 来玩微信跳一跳</a></p>\n<h2>使用须知:</h2>\n<p>由于本人手上没有mac设备(ios调试需要mac设备的支持),遂只开发了安卓端的脚本,</p>\n<h2>声明:</h2>\n<p>本脚本仅供个人测试和代码分享,请勿做商业用途以及恶意刷榜工具,仅供参考</p>\n</div>","title":"微信跳一跳跳跃脚本NodeJS版本(自动版)","last_reply_at":"2018-01-18T11:17:00.571Z","good":false,"top":false,"reply_count":4,"visit_count":2310,"create_at":"2018-01-05T07:03:11.942Z","author":{"loginname":"JesseWeb","avatar_url":"https://avatars0.githubusercontent.com/u/23567445?v=4&s=120"}},{"id":"5a604732afa0a121784a8d28","author_id":"5a5d5e809288dc8153287e4f","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"//dn-cnode.qbox.me/FpISR8xl9cWaE5VFdT0AhJw8lZtc\" alt=\"TIM截图20180118150428.png\"></p>\n<p><a href=\"https://stackoverflow.com/questions/30452263/is-there-a-mechanism-to-loop-x-times-in-es6-ecmascript-6-without-mutable-varia\">来自这里</a></p>\n<p><strong>看到这个直接懵了，这是啥。。。。。</strong></p>\n<p><strong>用babel处理了下才算能明白</strong>\n<img src=\"//dn-cnode.qbox.me/FrWu3a9E5GETjkSqbTpe_EwjrvvV\" alt=\"TIM图片20180118143855.png\"></p>\n</div>","title":"哎呀妈呀，这ES6语法，害我想了大半个钟头！","last_reply_at":"2018-01-18T09:51:20.757Z","good":false,"top":false,"reply_count":1,"visit_count":261,"create_at":"2018-01-18T07:05:22.291Z","author":{"loginname":"baofengyv","avatar_url":"https://avatars3.githubusercontent.com/u/5669938?v=4&s=120"}},{"id":"5a5c59669288dc8153287e30","author_id":"5655f2b8f811b9734d550686","tab":"share","content":"<div class=\"markdown-text\"><p><strong>➨ 报告电子版至听云官方博客下载：<a href=\"http://blog.tingyun.com/web/article/detail/1352\">http://blog.tingyun.com/web/article/detail/1352</a></strong></p>\n<h4>评测说明</h4>\n<p>评测目标：同一应用（网站）在不同云上的用户访问体验，以及对云资源的使用\n洞察周期及范围：2017年4月-2017年9月\n访问量：6642000PV\n评测工具：听云Network、听云Server、听云Sys、压力IO程序、云计算调查问卷</p>\n<h4>云服务配置</h4>\n<p><img src=\"//dn-cnode.qbox.me/FsRd_yNGpU_4twVGPqv7z-vMPRIM\" alt=\"2.jpg\"></p>\n<h4>国内云服务现状</h4>\n<p>在向智能时代演进的过程中，云计算，大数据和人工智能等作为最强劲的推动力，正在成为人们生活和工作中不可缺少的部分。如今大多数人对于云计算一词早已有了一定的了解，但是云计算的真正含义相信没有多少人能说的明白。</p>\n<p>据IDC预计，在2020年之前，中国的IaaS市场需求仍然很大，年复合增长率将有36.6%的提升空间。而整个云计算服务市场将以每年32.2%的速度增长，2020年将达到50亿美元以上的市场规模。因此在互联网时代的浪潮中，云计算服务从落地到成熟所花费的时间将会不断缩短，其市场份额的增速也会越来越快。</p>\n<p>随着云计算的热潮在中国兴起，越来越多的云服务厂商加入到这场“厮杀”中。而对于云的选择也成为了越来越多企业所关注的重点，在现阶段各家云都有各自所关注的重点，每一家都有各自的优势。而听云的云评测报告就完美的对每家云的各项指标进行了全方位的测试，在报告中显露出了各家云的优势及不足，为企业做云的选型提供相应的参考。</p>\n<h4>关键挑战</h4>\n<p>AWS、Azure、IBM等为代表的全球领先的云计算厂商也看到了中国目前庞大的市场需求，相继进入中国开展业务，并凭借其自身雄厚的技术实力，在进入国内云服务市场后迅速占领了一定份额，虽尚未对阿里云、腾讯云等国内云服务巨头产生实质性的影响，但是其对国内中小型云厂商却带来了极大的挑战。</p>\n<p>国内云计算市场未来发展的关键趋势在于能否将研发、生态系统与企业管理更好的结合。当前国内云计算服务仍处于“单打独斗，提供单向服务”的阶段，完整生态模式尚未搭建完成。</p>\n<p>生态数据安全问题，目前国内云计算发展速度过快，导致数据安全方面在整体发展上略有滞后。由于全行业均向互联网靠拢，企业无形的数字资产价值尤为突出，而当前国内云服务提供商无法提供完整生态环境，因此如何在短时间内提升自身的安全防范能力，将成为当前国内云服务提供商急需提高的重要部分。</p>\n<h4>评测方法说明</h4>\n<p><strong>1.听云云计算调查问卷</strong></p>\n<p>通过听云《2017云计算调查问卷》对计算，存储、网络、弹性伸缩、监控、技术支持与数据服务中共计132项能力对云服务能力及基础设施进行调查，并根据调查结果对各家云进行全方位的评测。</p>\n<p><em>听云云评测调查问卷架构图详见：附表一</em></p>\n<p><strong>2.验证式评测</strong></p>\n<p>所有云服务通过k8s进行统一部署监控，每家云的服务器通过运行Wordpress程序并通过听云Network模拟真实用户发起持续访问，同时使用压力IO程序来对服务器进行加压（具体加压方法为，同一压力IO 程序部署在不同的云服务中从而提高服务器CPU压力，不同云服务在运行压力IO程序后所消耗CPU比例不同，从而体现出云服务CPU性能差异），最后通过听云Server和听云Sys对服务端性能进行评测。</p>\n<p><em>验证式评测架构图详见：附表二</em></p>\n<h4>评测架构</h4>\n<p><img src=\"//dn-cnode.qbox.me/FpcHwFiywqCoJqt82JVsMkHc81Kh\" alt=\"3.jpg\">\n<img src=\"//dn-cnode.qbox.me/Fk87Pv-AqWw7BFpz0V608B2yLwBL\" alt=\"4.jpg\"></p>\n<h2>一、云计算综合用户体验</h2>\n<p>自我国进入互联网时代后，互联网行业的发展已经日新月异，“快”一直是互联网行业的极致追求。而作为互联网行业的命门，网络性能问题则一直是影响互联网产品发展趋势的重要因素之一。而网络问题的多样性、频发性、不重复性导致了每次运维人员均无法快速有效地诊断故障原因，从而白白流失故障修复的黄金时间。再加上如三大运营商间的网络延迟等国内特有的网络性能问题，使得国内的网络环境尤为特殊。而网络环境的变化之快，更是我们无法预料的。</p>\n<p>影响网络性能表现的指标有首页打开成功率、首页打开时间及首屏时间（图中的各地区用户体验得分是根据本次听云评分标准，并由这三项相加得出），而影响这三个指标的性能因素有DNS时间、建连时间、首包时间、延时及丢包率。</p>\n<p><img src=\"//dn-cnode.qbox.me/Fo16VCFug5WTBCPp17rfBxl7hIyI\" alt=\"5.jpg\">\n<img src=\"//dn-cnode.qbox.me/FuLJjDuSEK9R0VT5zDxnwGv0mr36\" alt=\"6.jpg\">\n<img src=\"//dn-cnode.qbox.me/Fso4bXbEO-FUU0v6qQ3jOBPAYE3P\" alt=\"7.jpg\"></p>\n<p>从全国地图来看，在全国范围内，山西和陕西的整体网络性能用户体验表现最为优异。其中，以山西地区为例，经听云测试得出，阿里云在山西地区的首屏时间为1.21s，首页打开成功率为99.96%，首页打开时间为2.93s；根据听云本次的分值计算规则，故而阿里云在山西地区的网络用户体验得分为28。</p>\n<p>性能指标部分，DNS时间部分，上海地区最慢，达到了9. 20ms，而青海地区最快，为1.42ms；建连时间部分，西藏地区最慢，达到了102.24ms，北京地区最快，为30.32ms；首包时间部分，云南地区耗时最长，达到了298.28ms，北京地区耗时最短，为234.55ms；延时部分，西藏地区延时最大，达到了75ms，北京地区延时最小，为16ms；丢包率部分，湖北地区丢包率最高，达到了2.17%，江西地区丢包率最低，为0.12%。根据以上指标计算得出各地区各项指标的综合得分情况如雷达图所示。</p>\n<p><img src=\"//dn-cnode.qbox.me/FhN-tG54MrrW4nnUU5inNC5HUwQs\" alt=\"8.jpg\">\n<img src=\"//dn-cnode.qbox.me/Fij6IGdwn91ugy-9RHRLqhF3M2-a\" alt=\"9.jpg\"></p>\n<p>从全国地图来看，在全国范围内，宁夏的整体网络性能用户体验表现最为优异。其中，经听云测试得出，AWS在宁夏地区的首屏时间为1.11s，首页打开成功率为99.98%，首页打开时间为1.89s；根据听云本次的分值计算规则，故而AWS在宁夏地区的网络用户体验得分为29。</p>\n<p>性能指标部分，DNS时间部分，山西地区最慢，达到了8.60ms，青海地区最快，为1.41ms； 建连时间部分，西藏地区最慢，达到了148.84ms，河北地区最快，为25.19ms；首包时间部分， 西藏地区耗时最长，达到了395.11ms，北京地区耗时最短，为201.97ms；延时部分，西藏地区延时最大，达到了76ms，北京地区延时最小，为10ms；丢包率部分，吉林地区丢包率最高，达到了1.65%，陕西与浙江地区丢包率最低，为0.01%。根据以上指标计算得出各地区各项指标的综合得分情况如雷达图所示。</p>\n<p><img src=\"//dn-cnode.qbox.me/Fm5xxexttbYZKxdlwXzBk8yLkOoV\" alt=\"10.jpg\">\n<img src=\"//dn-cnode.qbox.me/FgmG6d9cm0WX-Bn__LDIdnwv4zlI\" alt=\"11.jpg\"></p>\n<p>从全国地图来看，在全国范围内，山西的整体网络性能用户体验表现最为优异。其中，经听云测试得出，华为云在山西地区的首屏时间为1. 17s， 首页打开成功率为99.91%，首页打开时间为3.41s； 根据听云本次的分值计算规则，故而华为云在山西地区的网络用户体验得分为27。</p>\n<p>性能指标部分，DNS时间部分，山西地区最慢，达到了23.96ms，青海地区最快，为1.55ms；建连时间部分，西藏地区最慢，达到了107.32ms，北京地区最快，为30.62ms；首包时间部分，福建地区耗时最长，达到了308ms，陕西地区耗时最短，为228.94ms；延时部分，西藏地区延时最大，达到了79ms，北京地区延时最小，为11ms；丢包率部分，黑龙江地区丢包率最高，达到了10.30%， 江西、新疆与青海地区丢包率最低，为0.41%。根据以上指标计算得出各地区各项指标的综合得分情况如雷达图所示。</p>\n<p><img src=\"//dn-cnode.qbox.me/FrOUdBEmYAtUPXpsiEVfZb9T78BB\" alt=\"12.jpg\">\n<img src=\"//dn-cnode.qbox.me/Fjm3Wxb6tolX5BsA_J_QX-GKx6qN\" alt=\"13.jpg\"></p>\n<p>从全国地图来看，在全国范围内，山西的整体网络性能用户体验表现最为优异。其中，经听云测试得出，金山云在山西地区的首屏时间为1.15s， 首页打开成功率为99.94%，首页打开时间为3.46s；根据听云本次的分值计算规则，故而金山云在山西地区的网络用户体验得分为27。</p>\n<p>性能指标部分，DNS时间部分，上海地区最慢，达到了9.53ms，青海地区最快，为1.39ms；建连时间部分，贵州地区最慢，达到了108.54ms，北京地区最快，为21.09ms；首包时间部分，云南地区耗时最长，达到了318.89ms，北京地区耗时最短，为240.11ms；延时部分，西藏地区延时最大，达到了72ms，北京地区延时最小，为9ms；丢包率部分，山东地区丢包率最高，达到了2.45%，新疆地区丢包率最低，为0.20%。根据以上指标计算得出各地区各项指标的综合得分情况如雷达图所示。</p>\n<p>注：特别说明的是，评测期间我们随机抽取了金山云位于北京1区的机房用于验证评测，属传统扁平网络，此机房在本次报告发布时已不再售卖。</p>\n<p><img src=\"//dn-cnode.qbox.me/Fs2bZ9EfMqKHoZcsWpmyX8ztbFRO\" alt=\"14.jpg\">\n<img src=\"//dn-cnode.qbox.me/Fv2__HqiR4xpd6j5wMAjmimK-Nkf\" alt=\"15.jpg\"></p>\n<p>从全国地图来看，在全国范围内，山西、安徽以及河南的整体网络性能用户体验表现最为优异。其中以河南地区为例，经听云测试得出，腾讯云在河南地区的首屏时间为1.28s，首页打开成功率为99.95%，首页打开时间为3.67s；根据听云本次的分值计算规则，故而腾讯云在河南地区的网络用户体验得分为26。</p>\n<p>性能指标部分，DNS时间部分，上海地区最慢，达到了10.27ms，青海地区最快，为1.57ms；建连时间部分，西藏地区最慢，达到了102.98ms，辽宁地区最快，为37.14ms；首包时间部分，广西地区耗时最长，达到了288.77ms，河南地区耗时最短，为230.15ms；延时部分，西藏地区延时最大，达到了75ms，河北以及河南地区延时最小，为21ms；丢包率部分，陕西及贵州地区丢包率最高，达到了1.27%，江西地区丢包率最低，为0.16%。根据以上指标计算得出各地区各项指标的综合得分情况如雷达图所示。</p>\n<p><img src=\"//dn-cnode.qbox.me/FsKqYQE0kGbKuqKn6W9vM5o9sbPL\" alt=\"16.jpg\">\n<img src=\"//dn-cnode.qbox.me/Fmim1dem4PThohWJgJvtZYXVWWGJ\" alt=\"17.jpg\"></p>\n<p>从全国地图来看，在全国范围内，宁夏及青海的整体网络性能用户体验表现最为优异。其中以青海地区为例，经听云测试得出，UCloud在青海地区的首屏时间为1.10s，首页打开成功率为100%，首页打开时间为3.42s；根据听云本次的分值计算规则，故而UCloud在青海地区的网络用户体验得分为28。</p>\n<p>性能指标部分，DNS时间部分，上海地区最慢，达到了9.39ms，青海地区最快，为1.36ms； 建连时间部分，西藏地区最慢，达到了106.25ms，陕西地区最快，为38.59ms；首包时间部分，广西地区耗时最长，达到了332.95ms，北京地区耗时最短，为258.96ms；延时部分，西藏地区延时最大，达到了80ms，北京地区延时最小，为19ms；丢包率部分，云南地区丢包率最高，达到了5.21%，江西地区丢包率最低，为0.13%。根据以上指标计算得出各地区各项指标的综合得分情况如雷达图所示。</p>\n<p><img src=\"//dn-cnode.qbox.me/FpZGTmHNmdG4pJzo15THvCm7WZEs\" alt=\"18.jpg\">\n<img src=\"//dn-cnode.qbox.me/FoOvSOsJwj0WaiWHlI8Jh_5QqsN-\" alt=\"19.jpg\"></p>\n<p>从全国地图来看，在全国范围内，微软云在宁夏、青海、山西、甘肃、河南以及河北的整体网络性能用户体验表现最为优异。其中以河北地区为例，经听云测试得出，微软云在河北地区的首屏时间为1.13s，首页打开成功率为97.64%，首页打开时间为3.96s；根据听云本次的分值计算规则，故而微软云在河北地区网络用户体验得分为25。</p>\n<p>性能指标部分，DNS时间部分，山西地区最慢，达到了8.65ms，青海地区最快，为1.40ms；建连时间部分，贵州地区最慢，达到了107.10ms，山西地区最快，为25.91ms；首包时间部分，广西地区耗时最长，达到了319.71ms，北京地区耗时最短，为216ms；延时部分，云南地区延时最大，达到了73ms，天津地区延时最小，为8ms；丢包率部分，黑龙江地区丢包率最高，达到了1.29%，四川地区丢包率最低，为0.1%。根据以上指标计算得出各地区各项指标的综合得分情况如雷达图所示。</p>\n<p><img src=\"//dn-cnode.qbox.me/Fu5EezWr5Z-O3IfBwOta-6kreAgz\" alt=\"20.jpg\">\n<img src=\"//dn-cnode.qbox.me/FhChehouG3d4_Q88SR3_nq0XxtkC\" alt=\"21.jpg\"></p>\n<p>从全国地图来看，在全国范围内，移动云在山东的整体网络性能用户体验表现最为优异。其中以山东地区为例，经听云测试得出，移动云在山东地区的首屏时间为1.96s，首页打开成功率为99.82%，首页打开时间为4.76s；根据听云本次的分值计算规则，故而移动云在山东地区的网络用户体验得分为22。</p>\n<p>性能指标部分，DNS时间部分，山西地区最慢，达到了12.60ms，新疆地区最快，为1.65ms；建连时间部分，西藏地区最慢，达到了136.89ms，江苏地区最快，为62.05ms；首包时间部分，内蒙古地区耗时最长，达到了417.71ms，海南地区耗时最短，为330.67ms；延时部分，西藏地区延时最大，达到了97ms，广西及海南地区延时最小，为24ms；丢包率部分，北京地区丢包率最高，达到了9.45%，重庆地区丢包率最低，为0.1%。根据以上指标计算得出各地区各项指标的综合得分情况如雷达图所示。</p>\n<h2>二、云计算性能与可用性</h2>\n<p>“性能为先、用户为王”这些名词伴随着移动互联网的发展逐渐深入人心。云服务相比传统IDC机房，其优势就是减少成本、方便维护以及高可用，而高可用则正是这三者中唯一影响企业营收的重要因素。并且，云服务可用性的高低，是可以直接在使用过程中感知到的，这一部分，会是所有云服务提供商最为关注的一部分。</p>\n<p>分值计算部分，听云有自己的一套评分标准，通过对System-CPU使用率、User-CPU使用率、系统负载等图中所含的性能指标进行分值为1-10的划分。</p>\n<p><img src=\"//dn-cnode.qbox.me/Fvb5hcu6AY9Wkdf1ad1A0eOzQwhA\" alt=\"22.jpg\"></p>\n<p>阿里云在云计算可用性方面，Stolen CPU usage是它最大的优势，经听云详细测评后得出其详细数据，阿里云Stolen CPU usage为0。相较于这方面的优势，其System-CPU使用率和磁盘IO-写速率是最主要的两个弱项，其对应数据System-CPU使用率为45.21%、磁盘IO-写速率为32.18MB/s。根据听云此次的分值计算标准，评分结果如图上所示。</p>\n<p><img src=\"//dn-cnode.qbox.me/FgUJSmXRjAlFPX1M1X3pst4tZLTc\" alt=\"23.jpg\"></p>\n<p>AWS在云计算可用性方面，System-CPU使用率、User-CPU使用率以及IO wait CPU使用率是它最大的优势，经听云详细测评后得出其详细数据：分别为System-CPU使用率为21.64%，User-CPU使用率为7.91%，IO wait CPU使用率为0.000009%。相较于这三方面的优势，其磁盘IO-写速率以及磁盘IO读速率是最主要的两个弱项，其中磁盘IO写速率具体数据为33.34 MB/s，磁盘IO读速率则为40.75MB/s。根据听云此次的分值计算标准，评分结果如图上所示。</p>\n<p><img src=\"//dn-cnode.qbox.me/FktTdds56KkJ4r62efzrc6FAnLWX\" alt=\"24.jpg\"></p>\n<p>华为云在云计算可用性方面，Stolen CPU usage与磁盘IO-写速率是其最大的优势，所对应的详细数据Stolen CPU usage为0，磁盘IO-写速率为52.34MB/s。与之相反，系统负载及System-CPU使用率是其两个最大的弱项，系统负载为3.06，System-CPU使用率为41.85%。根据听云此次的分值计算标准，评分结果如图上所示。</p>\n<p><img src=\"//dn-cnode.qbox.me/FoCitJXVcHrkkwiGzREUFt7T_ehk\" alt=\"25.jpg\"></p>\n<p>金山云在云计算可用性方面，数据库响应时间是其最大的卖点。此次数据库响应时间指标是由Select、Insert、Update、Delete和Call这五项数据库操作时间之和与0.2相乘所得出的结果，金山云的数据库响应时间为0.21ms，在本次评测云厂商之中处于领先地位。相反，其System-CPU使用率则是其最弱的一项，所对应数据为45.05%。根据听云此次的分值计算标准，评分结果如图上所示。</p>\n<p><img src=\"//dn-cnode.qbox.me/FjgJOatCZ7Epg-X72BX79zmTHpU5\" alt=\"26.jpg\"></p>\n<p>腾讯云在云计算可用性放面，Stolen CPU usage是其最大的优势之一，经听云详细测评后，得出Stolen CPU usage为0；相较于这方面的优势，System-CPU使用率和IO wait CPU使用率是其最弱的两项，其中System-CPU使用率为44.82%，IO wait CPU使用率0.32%。根据听云此次的分值计算标准，评分结果如图上所示。</p>\n<p><img src=\"//dn-cnode.qbox.me/FgoxoUzGQx3Lvk8HPr-a5ciIeuT0\" alt=\"27.jpg\"></p>\n<p>UCloud在云计算可用性方面，系统负载、数据库响应时间与Stolen CPU usage是其最大的三个优势，经听云详细测评后，得出UCloud系统负载的详细数据为1.08，数据库响应时间为0.17ms，Stolen CPU usage为0.02%；相较于这两方面的优势，System-CPU使用率是其最大的弱势，其中System-CPU 的详细数据为41.47%。根据听云此次的分值计算标准，评分结果如图上所示。</p>\n<p><img src=\"//dn-cnode.qbox.me/FjEV7vLl61mrxiCdo7ExogAZelse\" alt=\"28.jpg\"></p>\n<p>微软云在云计算可用性方面，Stolen CPU usage是最大优势，经听云详细测评后，得出微软云的Stolen CPU usage详细数据为0；同时，其系统负载与磁盘IO-读速率则是微软云的两处弱项，其中系统负载的详细数据为2.83，磁盘IO-读速率的详细数据为45.91MB/s。根据听云此次的分值计算标准，评分结果如图上所示。</p>\n<p><img src=\"//dn-cnode.qbox.me/FiQPKI_kn5z--FesPhYfIpQ2KmAk\" alt=\"29.jpg\"></p>\n<p>移动云在云计算可用性方面，磁盘IO-读速率与Stolen CPU usage是其最大的两处优势，经听云详细测评后，得出移动云的磁盘IO-读速率详细数据为97.23MB/s，是本次所有评测云厂商中性能最优的，另外移动云的Stolen CPU usage的详细数据为0；同时，System-CPU使用率是其最弱的一项，其详细数据为43.42%。根据听云此次的分值计算标准，评分结果如图上所示。</p>\n<h2>三、云计算易用性</h2>\n<p>以使用者为中心，操作简单、性价比高、功能完善等等，这些不仅限于2C端，2B端也一样适用。每个人都在追求效率的最大化，都在追求在最短时间内完成最大效益的工作。所以云计算如何体现出自身的优越性，就在于与传统数据中心相比，如何用最少的努力发挥最大的效能。同理，在争夺用户的过程中，哪一方的操作简单，功能实用且覆盖面广，那这一方就会拥有更多的用户。</p>\n<p>易用性评分标准，通过结合听云《2017云计算调查问卷》与自身对云服务商的实际评测结果综合得出，最后换算为百分制，分值范围为0-100。</p>\n<p><img src=\"//dn-cnode.qbox.me/FmYZZ1ZvnKg76_C9EehJRNXKbCDC\" alt=\"30.jpg\"></p>\n<p>阿里云在云计算易用性方面， 监控和网络是其最优的两项，其中监控部分，阿里云的警报通知方式、支持第三方监测软件以及自定义服务健康控制台历史天数方面均位于行业前列。阿里云对于实例间的网络加密、NAT网关、多虚拟NIC等网络部分的支持也做到行业中较高的水平。</p>\n<p><img src=\"//dn-cnode.qbox.me/FrfzuPgjJ2ziEI5NgOg6qxNzoNC6\" alt=\"31.jpg\"></p>\n<p>AWS在云计算易用性方面，监控、弹性伸缩以及网络等都是AWS在易用性方面的优势所在，但是从图中可看其出存储服务明显落后于其它服务， 一方面是由于当前用户对于存储需求类型的不断变化，国内云计算市场普遍对于这种情况反应不及时，另一方面由于初进国内市场，对于国内企业在存储方面的实战需求并不十分清楚，从而造成现在对于存储服务支持度较低的局面。</p>\n<p><img src=\"//dn-cnode.qbox.me/FvCM42sHZqlQT0rEWOwX2H876KEj\" alt=\"32.jpg\"></p>\n<p>华为云在云计算易用性方面，弹性伸缩是其表现最为良好的一部分，其对健康实例替换、静态弹性伸缩服务等方面的支持程度较高。其它方面虽然相比弹性伸缩而言支持程度不够，但是目前来说是处于同步发展的阶段，并没有明显的弱项。</p>\n<p><img src=\"//dn-cnode.qbox.me/Fpx73-fG9kKXpRdCoNlNK5psI_-W\" alt=\"33.jpg\"></p>\n<p>金山云在云计算易用性方面，其弹性伸缩是所有云评测厂商中表现最好的，对于预约增加，减少实例池的实例数量、故障实例替换为健康实例的支持度很高；但是对于存储方面，如为每个对象分配一个或多个元数据标签、指定某些存储交互的优先级等方面的支持力度还不够。同时体系化的大数据平台整合将是未来的一大趋势，在这一趋势下，通过推出一系列包括行业解决方案定制、用户画像分析、优化数据传输及迁移等各个详细划分的数据服务，金山云将继续自己的全面均衡的发展路线。</p>\n<p><img src=\"//dn-cnode.qbox.me/FgbIMRre7CZyOKQ6l0_Rh9A1LVTI\" alt=\"34.jpg\"></p>\n<p>腾讯云在云计算易用性方面，对于易用性服务的支持表现较为平滑，没有特别突出的优势但是也没有明显的劣势，整体而言对于弹性伸缩、网络以及技术支持与服务方面的支持度比较高。同时从报告所包含的云服务提供商整体表现上来看，各家所提供的存储服务能力并没有完全跟上市场的需求，可见存储服务拥有极大的发展潜力，以持续数据保护为例，其作用是在云服务发生任何故障及问题时能对企业数据及时进行灾备，这是用户在当前以及将来很难改变的重要需求之一，因此腾讯云在存储服务上的持续发力势必将进一步巩固自身在易用性方面的优势。</p>\n<p><img src=\"//dn-cnode.qbox.me/Frt5T9ntoyiOSXRZkPgMf9tPNVsy\" alt=\"35.jpg\"></p>\n<p>UCloud在云计算易用性性方面，对于弹性伸缩和计算实例的支持是它的两个亮点，以计算实例为例，其对于VM主机故障恢复、实例维护及故障通知以及Windows、Linux系统镜像的支持等方面有着很高的支持度；但是相较于其他方面，对于存储服务的支持程度明显不够。</p>\n<p><img src=\"//dn-cnode.qbox.me/FpjqBxEfeuJbswhHFZaPnw92u9lM\" alt=\"36.jpg\"></p>\n<p>微软云在云计算易用性方面表现较为均衡，弹性伸缩是表现最为良好的服务之一，对于负载均衡的配置，动态弹性伸缩等方面的服务支持度较高。但是对于存储服务的支持力度则远远不够，比如不支持SSD混合存储、NFS协议等，总体来说对于存储方面的服务支持还有待提高。</p>\n<p><img src=\"//dn-cnode.qbox.me/FuwNH-hAduc96vlCIjTIVHllXIjr\" alt=\"37.jpg\"></p>\n<p>移动云在云计算易用性方面，其技术支持与服务方面领先于其它评测中的云厂商，无论是云端还是数据机房，数据安全以及灾备能力永远是最受关注的两个点，而移动云的技术支持与服务部分则是领先于上述其它云服务提供商，这也使其平台级异地灾备的能力得到了良好的体现，同时巩固并持续发展这一优势，对于稳扎稳打的移动云就目前的情况来说更为合适。但是相较于这方面，移动云对于数据服务和存储方面的支持程度还有待完善。</p>\n<h4>评测指标说明</h4>\n<p><strong>1.用户体验指标：</strong></p>\n<p>首屏时间：浏览器显示第一屏主页面的消耗时间。首屏的定义以1024X768像素尺寸为标准。从开始监测开始计时，到IE浏览器页面显示高度达到768像素且此区域有内容显示之后的时间。\n首页打开时间：首页打开时间是指，打开一个网页的总消耗时间，即从DNS解析开始到浏览器返回完成时的时间。\n首页打开成功率：首页打开成功率是指成功打开网页次数与总访问次数的比值。\nDNS时间：通过域名解析服务（DNS），将指定的域名解析成IP地址的消耗时间。\n建连时间：IE浏览器和Web服务器建立TCP/IP连接的消耗时间。\n首包时间：首包时间是指浏览器从发送HTTP请求结束开始，到接收到Web服务器返回的第一个数据包的消耗时间。\n延时：延时是指一个报文或分组从一个网络的一端传送到另一个端所需要的时间。\n丢包率：丢包率是指测试中所丢失数据包数量占所发送数据组的比率。</p>\n<p><strong>2.云计算性能与可用性指标：</strong></p>\n<p>System-CPU使用率：系统执行系统进程占用CPU的比例。\nUser-CPU使用率：系统执行用户进程所占用CPU比例。\nStolen CPU usage：服务器资源泄漏所占用的CPU比例（此项指标过高说明服务器出现了资源隔离的问题）。\nIO wait CPU使用率：系统在执行io操作时所占用的CPU比例。\n数据库响应时间：数据库5种SQL操作（INSERT、UPDATE、SELECT、DELETE、CALL）的平均响应时间。\n磁盘IO-读速率：每秒进行读（I/O）操作的大小。\n磁盘IO-写速率：每秒进行写（I/O）操作的大小。\n服务器响应时间：应用服务器从收到请求到返回响应的时间。\n系统负载：系统CPU繁忙程度的度量，即有多少进程在等待被CPU调度。</p>\n<p><strong>3.云计算易用性指标：</strong></p>\n<p>数据服务：数据服务是指云厂商对数据处理组件支持能力的体现。\n监控：监控是指云厂商对用户所选服务器运行状况的监控性能。\n弹性伸缩：弹性伸缩是指云厂商针对用户需求和策略自动调整其弹性计算资源的管理服务。\n网络：网络是指云厂商基础设施中的网络建设情况。\n存储：存储是指云厂商对与存储服务的支持情况。\n计算实例：计算实例是指云厂商服务器支持情况及其基础设施建设情况。\n技术支持与服务：技术支持与服务是指云厂商对用户所提供的支持及服务水平的情况。</p>\n<p><em>注：</em>\n<em>1.本次评测中所选运营商网络为（中国移动，中国联通，中国电信，中国铁通，教育网）各运营商所占比例为相同比例。评测中所选实例均为相同配置主机，系统盘为创建实例时系统自动提供的系统盘（没有单独挂载磁盘）。</em>\n<em>2.本报告中所有雷达图中分值越高所占面积越大。</em></p>\n</div>","title":"《2017云计算评测报告》：带你了解 AWS、阿里云、腾讯云等八家云计算服务提供商的综合用户体验情况","last_reply_at":"2018-01-18T09:48:23.763Z","good":false,"top":false,"reply_count":2,"visit_count":381,"create_at":"2018-01-15T07:33:58.233Z","author":{"loginname":"TINGYUN-APM","avatar_url":"https://avatars.githubusercontent.com/u/16021003?v=3&s=120"}},{"id":"5a5ff20d9d371d4a059eebbe","author_id":"5a5ff1869288dc8153287f0b","tab":"ask","content":"<div class=\"markdown-text\"><p>Node Version: v8.9.3\nEgg Version: v2.0.0</p>\n<p>在使用eggjs框架时遇到如下的问题，\n<strong>我的测试环境</strong>\n/etc/hosts\n10.200.33.33 <a href=\"http://haha.ttt.com\">haha.ttt.com</a> 映射到测试服务器</p>\n<p>在代码中controller层向该地址请求数据\n<code>ctx.curl('http://haha.ttt.com', opts);</code>\n这里url是nginx服务器的域名，因为是测试环境，所以配置了hosts映射，但此时发出的请求，会返回404，\n感觉像是nginx反向代理无法生效</p>\n<p>直接在环境中使用curl命令去请求域名是可以代理成功的，\n但在代码中使用域名就会返回404，和curl直接请求IP是一样的情况，很困惑。。。</p>\n</div>","title":"使用egg.js过程中遇到的问题：curl请求到nginx服务器，但目标的反向代理无法生效","last_reply_at":"2018-01-18T09:44:16.042Z","good":false,"top":false,"reply_count":5,"visit_count":140,"create_at":"2018-01-18T01:02:05.280Z","author":{"loginname":"HOTTIN","avatar_url":"https://avatars2.githubusercontent.com/u/12428754?v=4&s=120"}},{"id":"5a606a26ce45d4404514611e","author_id":"5909444b782dbc4b183ecfe2","tab":"ask","content":"<div class=\"markdown-text\"><p>早起写的博客，使用redux硬刚，现在要重构了.</p>\n<p>看到那么多redux的文件都怕…</p>\n<p>求推荐一个，既能复用redux的中间件，又不那么啰嗦的</p>\n<p><img src=\"http://i03.pictn.sogoucdn.com/e8eca196eeee8961\" alt></p>\n</div>","title":"求推荐个基于redux的状态管理库，除了dva之外","last_reply_at":"2018-01-18T09:34:30.420Z","good":false,"top":false,"reply_count":0,"visit_count":56,"create_at":"2018-01-18T09:34:30.420Z","author":{"loginname":"axetroy","avatar_url":"https://avatars2.githubusercontent.com/u/9758711?v=4&s=120"}},{"id":"59e86107a9a1e19f3634c871","author_id":"58f8dcba31e8c2bb1c3dcc26","tab":"ask","content":"<div class=\"markdown-text\"><p>如题，公司选型中有多少选择egg.js的？（个人项目除外）。</p>\n<p>个人感觉，egg的插件还不是特别完善，看到egg issue问题中好多人提的问题，作者都想大家去PR，这出发点是好的，但是在公司中，遇到问题就需要自己去PR的话，很花时间啊。如果是个人项目还是可以贡献代码的，因为时间允许。如何做出选择，我的备选方案是koa2和egg。我更倾向于koa2。</p>\n</div>","title":"公司选型中有多少选择egg.js的？（个人项目除外）","last_reply_at":"2018-01-18T09:20:34.876Z","good":false,"top":false,"reply_count":38,"visit_count":2668,"create_at":"2017-10-19T08:23:35.792Z","author":{"loginname":"MedusaLeee","avatar_url":"https://avatars0.githubusercontent.com/u/17797874?v=4&s=120"}},{"id":"5a6010e19d371d4a059eebd2","author_id":"5a5d5e809288dc8153287e4f","tab":"share","content":"<div class=\"markdown-text\"><p>什么 Java Python…  未来是nodejs的！</p>\n<blockquote>\n<blockquote>\n<p>What?  Why?\n\t&lt;&lt; Simple !!!</p>\n</blockquote>\n<blockquote>\n<p>Only Simple?\n\t&lt;&lt; It’s enough.</p>\n</blockquote>\n</blockquote>\n</div>","title":"nodejs称霸一切 :)","last_reply_at":"2018-01-18T09:12:32.058Z","good":false,"top":false,"reply_count":10,"visit_count":479,"create_at":"2018-01-18T03:13:37.139Z","author":{"loginname":"baofengyv","avatar_url":"https://avatars3.githubusercontent.com/u/5669938?v=4&s=120"}},{"id":"5a41e5e7d1536726354b8140","author_id":"54009f5ccd66f2eb37190485","tab":"share","content":"<div class=\"markdown-text\"><p>Live 简介\n你好，我是 i5ting ，江湖人称「狼叔」，目前是阿里巴巴技术专家，斯达克学院（ StuQ ）明星讲师， Node.js 技术布道者。曾就职于去哪儿、新浪、网秦，做过前端、后端、数据分析，是一名全栈技术的实践者。</p>\n<p>现在，越来越多的科技公司和开发者开始使用 Node.js 开发各种应用。Node.js除了能够辅助大前端开发外，还可以编写Web应用，封装Api，组装RPC服务等，甚至是开发VSCode编辑器一样的PC客户端。和其它技术相比， Node.js 简单易学，性能好、部署容易，能够轻松处理高并发场景下的大量服务器请求。Node.js 周边的生态也非常强大，NPM（Node包管理）上有超过60万个模块，日下超过载量3亿次。但编写 Node.js 代码对新人和其它语言背景的开发者来说，不是一件容易的事，在入门之前需要弄懂不少复杂的概念。</p>\n<p>我身边也有很多人问我：如何学习 Node.js ？作为一名 Node.js 布道者，我做过很多 Node.js 普及和推广的工作，对它的基本概念和核心模块都很熟悉； 此外，我还在撰写一本名为《更了不起的 Node.js 》的书，已经写了 2 年，积累了很丰富的资料，本次 Live 也将为你提供对 Node.js 更全面的解读。</p>\n<p>本次 Live 主要包括以下内容</p>\n<ol>\n<li>前言：学习 Node.js 的三个境界</li>\n<li>准备：\n<ul>\n<li>Node 用途那么多，我该从哪里学起？</li>\n<li>Node Web 框架那么多，我该怎么选？</li>\n<li>关于 Node 的书几乎都过时了，我该买哪本？</li>\n</ul>\n</li>\n<li>延伸：大前端变化那么快，如何才能做到每日精进？</li>\n<li>实践：从招聘角度来看， Node.js 开发需要具备哪些技能？</li>\n<li>答疑：回答大家的问题</li>\n</ol>\n<p>本次Live主要是科普，适用新用户和比较迷茫的Node朋友，参加地址</p>\n<p><a href=\"https://www.zhihu.com/lives/928687583372926976\">https://www.zhihu.com/lives/928687583372926976</a></p>\n</div>","title":"【知乎Live】狼叔：如何正确的学习Node.js","last_reply_at":"2018-01-18T09:09:20.461Z","good":false,"top":false,"reply_count":16,"visit_count":2320,"create_at":"2017-12-26T06:02:15.095Z","author":{"loginname":"i5ting","avatar_url":"https://avatars3.githubusercontent.com/u/3118295?v=4&s=120"}},{"id":"58fd8ec7523b9d0956dad945","author_id":"57b84dc4b32043f532d40da6","tab":"share","content":"<div class=\"markdown-text\"><h2>koa</h2>\n<blockquote>\n<p><code>koa</code>是由<code>express</code>原班人马打造的一个更小、更富有表现力、更健壮的<code>web</code>框架。</p>\n</blockquote>\n<p>在我眼中，<code>koa</code>的确是比<code>express</code>轻量的多，<code>koa</code>给我的感觉更像是一个中间件框架，<code>koa</code>只是一个基础的架子，需要用到的相应的功能时，用相应的中间件来实现就好，诸如路由系统等。一个更好的点在于，<code>express</code>是基于回调来处理，至于回调到底有多么的不好，大家可以自行搜索来看。<code>koa1</code>基于的<code>co</code>库，所以<code>koa1</code>利用<code>Generator</code>来代替回调，而<code>koa2</code>由于<code>node</code>对<code>async/await</code>的支持，所以<code>koa2</code>利用的是<code>async/await</code>。关于<code>async</code>以及<code>co</code>库等，大家可以参考我之前写过的一篇文章（<a href=\"https://segmentfault.com/a/1190000008687414\">理解async</a>）。<code>koa</code>可以说是一个各种中间件的架子，下面就来看一下<code>koa</code>对于中间件部分的实现：</p>\n<h2>koa1的中间件</h2>\n<p><code>koa1</code>主要利用的是<code>Generator</code>来实现，一般来说，<code>koa1</code>的一个中间件大概是长这个样子的：</p>\n<pre class=\"prettyprint\"><code>app.use(function *(next){\n    console.log(1);\n    yield next;\n    console.log(5);\n});\napp.use(function *(next){\n    console.log(2);\n    yield next;\n    console.log(4);\n});\napp.use(function *(){\n    console.log(3);\n});\n</code></pre><p>这样的输出会是<code>1, 2, 3, 4, 5</code>，<code>koa</code>的中间件的实现主要依靠的是<code>koa-compose</code>：</p>\n<pre class=\"prettyprint language-js\"><code>function compose(middleware){\n  return function *(next){\n    if (!next) next = noop();\n\n    var i = middleware.length;\n    &#x2F;&#x2F; 组合中间件\n    while (i--) {\n      next = middleware[i].call(this, next);\n    }\n\n    return yield *next;\n  }\n}\nfunction *noop(){}\n</code></pre><p>源码非常的简单，实现的功能就是将所有的中间件串联起来，首先给倒数第一个中间件传入一个<code>noop</code>作为其<code>next</code>，再将这个整理后的倒数第一个中间作为<code>next</code>传入倒数第二个中间件，最终得到的<code>next</code>就是整理后的第一个中间件。说起来比较复杂，画图来看：</p>\n<p><img src=\"//dn-cnode.qbox.me/FqqHNh4U_H76zKWB2VVPeaFvbcIX\" alt=\"87399421-58faf1241df42_articlex.png\"></p>\n<p>实现的效果如同上图，与<code>redux</code>需要实现的目标类似，只要遇到了<code>yield next</code>就去执行下一个中间件，利用<code>co</code>库很容易将这个流程串联起来，下面来简单模拟下，中间件完整的实现：</p>\n<pre class=\"prettyprint\"><code>const middlewares = [];\n\nconst getTestMiddWare = (loggerA, loggerB) =&gt; {\n    return function *(next) {\n        console.log(loggerA);\n        yield next;\n        console.log(loggerB);\n    }\n};\nconst mid1 = getTestMiddWare(1, 4),\n    mid2 = getTestMiddWare(2, 3);\n\nconst getData = new Promise((resolve, reject) =&gt; {\n    setTimeout(() =&gt; resolve(&#x27;数据已经取出&#x27;), 1000);\n});\n\nfunction *response(next) {\n    &#x2F;&#x2F; 模拟异步读取数据库数据\n    const data = yield getData;\n    console.log(data);\n}\n\nmiddlewares.push(mid1, mid2, response);\n&#x2F;&#x2F; 简单模拟co库\nfunction co(gen) {\n    const ctx = this,\n        args = Array.prototype.slice.call(arguments, 1);\n    return new Promise((reslove, reject) =&gt; {\n        if (typeof gen === &#x27;function&#x27;) gen = gen.apply(ctx, args);\n        if (!gen || typeof gen.next !== &#x27;function&#x27;) return resolve(gen);\n\n        const baseHandle = handle =&gt; res =&gt; {\n            let ret;\n            try {\n                ret = gen[handle](res);\n            } catch(e) {\n                reject(e);\n            }\n            next(ret);\n        };\n        const onFulfilled = baseHandle(&#x27;next&#x27;),\n            onRejected = baseHandle(&#x27;throw&#x27;);\n            \n        onFulfilled();\n        function next(ret) {\n            if (ret.done) return reslove(ret.value);\n            &#x2F;&#x2F; 将yield的返回值转换为Proimse\n            let value = null;\n            if (typeof ret.value.then !== &#x27;function&#x27;) {\n                value = co(ret.value);\n            } else {\n                value = ret.value;\n            }\n            if (value) return value.then(onFulfilled, onRejected);\n            return onRejected(new TypeError(&#x27;yield type error&#x27;));\n        }\n    });\n}\n&#x2F;&#x2F; 调用方式\nconst gen = compose(middlewares);\nco(gen);\n</code></pre><h2>koa2的中间件</h2>\n<p>随着<code>node</code>对于<code>async/await</code>的支持，貌似不需要再借助于<code>co</code>这种工具库了，直接利用原生的就好，于是<code>koa</code>也做出了改变，来看目前的<code>koa-compose</code>：</p>\n<pre class=\"prettyprint\"><code>function compose (middleware) {\n  &#x2F;&#x2F; 参数检验\n  return function (context, next) {\n    &#x2F;&#x2F; last called middleware #\n    let index = -1\n    return dispatch(0)\n    function dispatch (i) {\n      if (i &lt;= index) return Promise.reject(new Error(&#x27;next() called multiple times&#x27;))\n      index = i\n      let fn = middleware[i]\n      &#x2F;&#x2F; 最后一个中间件的调用\n      if (i === middleware.length) fn = next\n      if (!fn) return Promise.resolve()\n      &#x2F;&#x2F; 用Promise包裹中间件，方便await调用\n      try {\n        return Promise.resolve(fn(context, function next () {\n          return dispatch(i + 1)\n        }))\n      } catch (err) {\n        return Promise.reject(err)\n      }\n    }\n  }\n}\n</code></pre><p><code>koa-compose</code>利用了<code>Promise</code>，<code>koa2</code>的中间件的参数也有一个变为了两个，而且执行下一个的中间件利用的是<code>await next()</code>，要达到与上面的示例代码的相同效果，需要更改中间件的写法：</p>\n<pre class=\"prettyprint\"><code>const middlewares = [];\nconst getTestMiddWare = (loggerA, loggerB) =&gt; async (ctx, next) =&gt; {\n    console.log(loggerA);\n    await next();\n    console.log(loggerB);\n};\n\nconst mid1 = getTestMiddWare(1, 4),\n    mid2 = getTestMiddWare(2, 3);\nconst response = async () =&gt; {\n    &#x2F;&#x2F; 模拟异步读取数据库数据\n    const data = await getData();\n    console.log(data);\n};\nconst getData = () =&gt; new Promise((resolve, reject) =&gt; {\n    setTimeout(() =&gt; resolve(&#x27;数据已经取出&#x27;), 1000);\n});\nmiddlewares.push(mid1, mid2);\n\n&#x2F;&#x2F; 调用方式\ncompose(middlewares)(null, response);\n</code></pre><h2>如何做到兼容</h2>\n<p>可以看到的是，<code>koa1</code>与<code>koa2</code>对于中间件的实现还是有着很多的不同的，将<code>koa1</code>的中间件直接拿到<code>koa2</code>下面来使用肯定是会出现错误的，如何兼容这两个版本也成了一个问题，<code>koa</code>团队写了一个包来是<code>koa1</code>的中间件可以用于<code>koa2</code>中，叫做<code>koa-convert</code>，先来看看这个包怎么使用：</p>\n<pre class=\"prettyprint\"><code>function *mid3(next) {\n    console.log(2, &#x27;koa1的中间件&#x27;);\n    yield next;\n    console.log(3, &#x27;koa1的中间件&#x27;);\n}\nconvert.compose(mid3)\n</code></pre><p>来看下这个包实现的思路：</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 将参数转为数组，对每一个koa1的中间件执行convert操作\nconvert.compose = function (arr) {\n  if (!Array.isArray(arr)) {\n    arr = Array.from(arguments)\n  }\n  return compose(arr.map(convert))\n}\n&#x2F;&#x2F; 关键在于convert的实现\nconst convert = mw =&gt; (ctx, next) =&gt; {\n    &#x2F;&#x2F; 借助co库，返回一个Promise，同时执行yield\n    return co.call(ctx, mw.call(ctx, createGenerator(next)));\n};\n\nfunction * createGenerator (next) {\n  &#x2F;*\n     next为koa-compomse中：\n     function next () {\n         return dispatch(i + 1)\n     }\n  *&#x2F;\n  return yield next()\n  &#x2F;&#x2F; 执行完koa1的中间件，又回到了利用await执行koa2中间件的正轨\n}\n</code></pre><p>个人感觉<code>koa-convert</code>的思路就是对<code>Generator</code>封装一层<code>Promise</code>，使上一个中间件可以利用<code>await next()</code>的方式调用，对于<code>Generator</code>的执行，利用<code>co</code>库，从而达到了兼容的目的。</p>\n</div>","title":"koa中间件机制详解","last_reply_at":"2018-01-18T08:48:26.073Z","good":true,"top":false,"reply_count":7,"visit_count":7817,"create_at":"2017-04-24T05:36:07.556Z","author":{"loginname":"zp1996","avatar_url":"https://avatars3.githubusercontent.com/u/14966444?v=4&s=120"}},{"id":"5a4db120ebc575dc49b27108","author_id":"547c35030ae47dec03aa2939","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"http://upload-images.jianshu.io/upload_images/145564-060eef2e34e2dcfd?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"vue's templates&amp;amp;react'JSX\"></p>\n<p><strong>React.js</strong>和<strong>Vue.js</strong>是这个星球上最流行的<strong>JavaScript</strong>库。它们都很强大，相对来说很容易获取和使用。</p>\n<p><strong>React</strong>和<strong>Vue</strong>的共性：</p>\n<ol>\n<li>\n<p>使用虚拟DOM。</p>\n</li>\n<li>\n<p>提供响应式视图组件。</p>\n</li>\n<li>\n<p>专注于开发过程中的一个方面。目前集中在视图层。</p>\n</li>\n</ol>\n<p>有这么多相似之处，你可以假设它们都是同一事物的不同版本。</p>\n<p>这两个库之间有一个主要的区别：它们如何让开发人员创建视图组件，反过来又可以应用程序。</p>\n<p>React采用<strong>JSX</strong>（这个词是react团队创造的）渲染内容到<strong>DOM</strong>。那么什么是JSX？基本上，JSX是一个JavaScript渲染功能，帮助你将你的HTML放到你的JavaScript代码中合适的地方。</p>\n<p>Vue采用不同的方法，使用HTML模板。使用Vue模板就像是用JSX就是他们都是创建使用JavaScript。主要的区别是，JSX函数在实际的HTML文件中从来不被使用，而Vue模板不是这样。</p>\n<p>特别说明下，Vue.js的相关课程可以<a href=\"http://www.hubwiz.com/course/?type=vue.js&amp;affid=cnodejs\">点击这里。</a></p>\n<h1>React JSX</h1>\n<p>我们将深入探讨JSX如何工作。假设你有一个要在DOM上显示的名称列表。你们公司最近的一份新员工名单。</p>\n<p>如果你使用的是普通的<strong>HTML</strong>，你首先需要创建一个index.html文件。然后，你将添加以下代码行。</p>\n<pre class=\"prettyprint\"><code>&lt;ul&gt;\n&lt;li&gt; John &lt;&#x2F;li&gt;\n&lt;li&gt; Sarah &lt;&#x2F;li&gt;\n&lt;li&gt; Kevin &lt;&#x2F;li&gt;\n&lt;li&gt; Alice &lt;&#x2F;li&gt;\n&lt;ul&gt;\n&lt;&#x2F;pre&gt;\n</code></pre><p>这里没什么好说的，只是普通的<strong>HTML</strong>代码。</p>\n<p>那么你使用<strong>JSX</strong>怎么做同样的事情？第一步是创建一个index.html文件。但是，不像以前那样添加完整的HTML，只需要添加一个简单的<strong>div</strong>元素。这个<strong>div</strong>将是容器元素，在那里您的所有<strong>React</strong>代码将被呈现。</p>\n<p>div将需要一个唯一的ID，这样React就知道如何可以找到它。facebook倾向于支持根关键字，所以让我们坚持这一点。</p>\n<pre class=\"prettyprint\"><code>&lt;div id=root&gt;&lt;&#x2F;div&gt;\n</code></pre><p>现在，走到最重要的一步。创建包含所有react代码的JavaScript文件。这是一个叫app.js的文件。</p>\n<p>你现在把所有的事情都排除在外，进入主事件。用JSX显示所有新员工到 DOM中。</p>\n<p>首先需要创建一个具有新雇员名称的数组。</p>\n<pre class=\"prettyprint\"><code>const names = [‘John’, ‘Sarah’, ‘Kevin’, ‘Alice’];\n</code></pre><p>从那里，您需要创建一个响应元素，它将动态地呈现整个名称列表。这你没有必要再手动显示每一个。</p>\n<pre class=\"prettyprint\"><code>&lt;ul&gt;\n{names.map(name =&gt; &lt;li&gt;{name}&lt;&#x2F;li&gt; )}\n&lt;&#x2F;ul&gt;\n);\n</code></pre><p>这里要注意的关键是，您不必创建单独的**&lt;li&gt;<strong>元素。你只需要描述你想让他们看一次，React会处理剩下的。这是一件非常给力的事。虽然你只有几个名字，但想象一下有成百上千的名单！你可以看到这当然是一个更好的方法。特别是如果</strong>&lt;li&gt;**元素，比这里用到的元素更复杂。</p>\n<p>代码的最后一步是需要将内容渲染到屏幕，主要是通过<strong>ReactDom</strong>的<strong>render</strong>渲染函数。</p>\n<pre class=\"prettyprint\"><code>ReactDOM.render(\ndisplayNewHires,\ndocument.getElementById(‘root’)\n);\n</code></pre><p>在这里，你在用div里的内容作出响应，通过<strong>displayNewHires</strong>渲染<strong>root</strong>元素。</p>\n<p>那么最终的React代码就应该是这个样子：</p>\n<pre class=\"prettyprint\"><code>const names = [‘John’, ‘Sarah’, ‘Kevin’, ‘Alice’];\nconst displayNewHires = (\n&lt;ul&gt;\n{names.map(name =&gt; &lt;li&gt;{name}&lt;&#x2F;li&gt; )}\n&lt;&#x2F;ul&gt;\n);\nReactDOM.render(\ndisplayNewHires,\ndocument.getElementById(‘root’)\n);\n</code></pre><p>这里要记住的一个关键是，这是所有的React代码。这意味着它都将编译成普通的JavaScript。下面是它最终看起来的样子：</p>\n<pre class=\"prettyprint\"><code>‘use strict’;\n\nvar names = [‘John’, ‘Sarah’, ‘Kevin’, ‘Alice’];\n\nvar displayNewHires = React.createElement(\n‘ul’,\nnull,\n\nnames.map(function (name) {\n return React.createElement(\n ‘li’,\n null,\n name\n );\n})\n);\n\nReactDOM.render(displayNewHires, document.getElementById(‘root’));\n</code></pre><p>这就是它的全部。现在有一个简单的React应用程序，它将显示名称列表。没有什么可以写的，但它应该能让你了解React的能力是什么。</p>\n<p>特别说明下，react.js的相关课程可以<a href=\"http://www.hubwiz.com/course/?type=react&amp;affid=cnodejs\">点击这里。</a></p>\n<h1>Vue.js Templates（模板）</h1>\n<p>按照最后一个示例，您将再次创建一个简单的应用程序，它将在浏览器上显示名称列表。</p>\n<p>你需要做的第一件事就是创建一个空的index.html文件。在该文件中，您将创建一个带有根ID的空<strong>div</strong>。记住，根只是个人偏好。你可以调用你的ID无论什么情况下。您只需确保稍后将HTML与JavaScript代码同步时匹配起来即可。</p>\n<p>这个div会像它在React中那样起作用。它会告诉JavaScript库，在这个示例中，开始改变的时候在哪里观察DOM。</p>\n<p>一旦这样做了，你将创建一个JavaScript文件，将存放Vue代码。称它为app.js，以便保持一致。</p>\n<p>现在你已经准备好你的文件，让我们看看Vue如何显示元素到浏览器。</p>\n<p>Vue使用模板的方法用它来操作DOM。这意味着你的HTML文件不仅会有一个空的div，比如在React中。实际上，您将在HTML文件中编写一部分代码。</p>\n<p>为了给你一个更好的提醒，回想一下使用普通HTML创建名称列表需要什么。一个**&lt;ul&gt;<strong>包含一些的</strong>&lt;li&gt;**元素。在Vue，你要做几乎相同的事情，只有少数的变化增加。</p>\n<p>创建一个**&lt;ul&gt;**。</p>\n<pre class=\"prettyprint\"><code>&lt;ul&gt;\n&lt;&#x2F;ul&gt;\n</code></pre><p>现在添加一个空的**&lt;li&gt;**。</p>\n<pre class=\"prettyprint\"><code>&lt;ul&gt;\n&lt;li&gt;\n&lt;&#x2F;li&gt;\n&lt;&#x2F;ul&gt;\n</code></pre><p>没什么新鲜的变化，通过增加一个指令，一个自定义的Vue的属性你的**&lt;li&gt;**元素。</p>\n<pre class=\"prettyprint\"><code>&lt;ul&gt;\n&lt;li v-for=’name in listOfNames’&gt;\n&lt;&#x2F;li&gt;\n&lt;&#x2F;ul&gt;\n</code></pre><p>指令是Vue直接进入HTML添加JavaScript功能的方式。它们都以V开头，后面跟着描述性的名字，让你知道他们在做什么。在这个实例中，它是for循环。每一个名字在你的名字列表listOfNames中，你可以从你的名单列表上复制这个&lt;li&gt;元素和更换一个新的&lt;li&gt;元素来确定一个的名字。</p>\n<p>现在，代码只需要最后一次编写。当前，它将为列表中的显示每个名称，但实际上并没有告诉它将把实际名称显示在浏览器上。为了解决这个问题，你将在你的&lt;li&gt;中插入一些类似<strong>mustache</strong>的语法。你可能在其他JavaScript库中看到的类似东西。</p>\n<pre class=\"prettyprint\"><code>&lt;ul&gt;\n&lt;li v-for=’name in listOfNames’&gt;\n{{name}}\n&lt;&#x2F;li&gt;\n&lt;&#x2F;ul&gt;\n</code></pre><p>现在&lt;li&gt; 元素是写完了。它现在将显示名字为listOfNames列表的每个项。记住name可以是任何其他的名称。你可以把它叫做item，它也会达到同样的目的。所有关键字都用作占位符，用于在列表中迭代。</p>\n<p>你需要做的最后一件事就是创建数据集和在实际应用程序中初始化Vue。</p>\n<p>这样做，你将需要创建一个新的Vue实例。通过将它分配给名为app的变量来实例化它。</p>\n<pre class=\"prettyprint\"><code>let app = new Vue({\n});\n</code></pre><p>现在，对象将包含一些参数。第一个是最重要的，<strong>el</strong> (element) 参数告诉Vue在DOM开始添加什么内容。就像你对你的React中的例子那样。</p>\n<pre class=\"prettyprint\"><code>let app = new Vue({\nel:’#root’,\n});\n</code></pre><p>最后一步是添加数据到Vue的应用。在Vue，所有的数据都将做为Vue实例的参数传送到应用程序。另外，每个Vue实例只能有一个每种类型参数。虽然有相当多的，但您只需要集中在两个例子，<strong>el</strong>和<strong>data</strong>。</p>\n<pre class=\"prettyprint\"><code>let app = new Vue({\nel:’#root’,\ndata: {\nlistOfNames: [‘Kevin’, ‘John’, ‘Sarah’, ‘Alice’]\n}\n});\n</code></pre><p>数据对象将接受一个数组<strong>listOfNames</strong>。现在，每当您想在应用程序中使用该数据集时，只需要使用指令调用它。很简单，对吧？</p>\n<p>这是最终的代码：</p>\n<h1>HTML</h1>\n<pre class=\"prettyprint\"><code>&lt;div id=”root”&gt;\n&lt;ul&gt;\n&lt;li v-for=’name in listOfNames’&gt;\n{{name}}\n&lt;&#x2F;li&gt;\n&lt;&#x2F;ul&gt;\n&lt;&#x2F;div&gt;\n</code></pre><h1>JavaScript</h1>\n<pre class=\"prettyprint\"><code>new Vue({\nel:”#root”,\ndata: {\nlistOfNames: [‘Kevin’, ‘John’, ‘Sarah’, ‘Alice’]\n}\n});\n</code></pre><h1>结论</h1>\n<p>现在你知道如何使用React和Vue创建两个简单的应用程序。他们都提供了强大的功能，虽然Vue看起来往往是更容易使用。还有需要记住，Vue也支持JSX的使用，虽然它不是首选的实现方法。</p>\n<p>无论哪种方式，Vue和React都是两个功能强大的库，你使用任何一个都不会有问题。</p>\n<p>如果你觉得这篇文章很有帮助，给我一些掌声。</p>\n<p>你可以在Twitter上跟踪我！</p>\n<p>汇智网（<a href=\"http://www.hubwiz.com/course/?type=vue.js&amp;affid=cnodejs\">www.hubwiz.com</a>，有很多很棒vue.js的课程包括vue.js\\vuex\\vue-router\\vue工程化等）的小智原创翻译。</p>\n</div>","title":"前端的对决：React的JSX与Vue的templates","last_reply_at":"2018-01-18T08:43:30.908Z","good":false,"top":false,"reply_count":12,"visit_count":1014,"create_at":"2018-01-04T04:44:16.207Z","author":{"loginname":"2596887568","avatar_url":"https://avatars3.githubusercontent.com/u/9349200?v=4&s=120"}},{"id":"5a571ba39d371d4a059eea07","author_id":"592147579e32cc84569a718f","tab":"ask","content":"<div class=\"markdown-text\"><p>看某本书，下面这种写法已经无效：\n<img src=\"//dn-cnode.qbox.me/FpwGpAWUApzb8zfVBYLWX9G7GeFi\" alt=\"image.png\"></p>\n</div>","title":"express如何实现表单中的method转换，比如：POST转成PUT","last_reply_at":"2018-01-18T08:41:29.793Z","good":false,"top":false,"reply_count":5,"visit_count":312,"create_at":"2018-01-11T08:09:07.622Z","author":{"loginname":"FEzhangjiarong","avatar_url":"https://avatars1.githubusercontent.com/u/17873970?v=4&s=120"}},{"id":"5a5c7a339d371d4a059eead8","author_id":"59ef17a09cf198a85bd2e243","tab":"share","content":"<div class=\"markdown-text\"><p>微信小程序商城更新最新版 v1.8，主要改进内容包括：</p>\n<p>1、修复用户首次拒绝授权后，点击重新登录会弹出授权窗口让用户重新授权；\n2、商品详情支持添加视频功能；\n3、用户收货地址现在支持从微信中读取了；\n4、修复了优惠券页面，当优惠券数量太多的时候导致底部的按钮样式错乱的问题；\n5、wxparse组件升级到最新版；\n6、去掉了商品详情页面两张图片之间的空隙，多图拼接更自然流畅；\n7、商品详情页面，增加“分享”按钮，方便用户分享，感谢 @☭淡淡一笑；\n8、增加了小程序引导界面，感谢 <a href=\"/user/qindiandadudu\">@qindiandadudu</a> 贡献代码；\n9、商品列表增加了“原价”的显示；\n10、增加了搜索功能，可根据关键词搜索商品；</p>\n<p>扫码演示：</p>\n<p><img src=\"//dn-cnode.qbox.me/Fu_AUhnS045L8SwPyRkQGaWTmd4d\" alt=\"111.jpeg\"></p>\n<p>开源项目地址：</p>\n<p><a href=\"https://github.com/EastWorld/wechat-app-mall\">https://github.com/EastWorld/wechat-app-mall</a></p>\n</div>","title":"微信小程序商城更新最新版 v1.8","last_reply_at":"2018-01-18T08:30:18.731Z","good":false,"top":false,"reply_count":2,"visit_count":415,"create_at":"2018-01-15T09:53:55.803Z","author":{"loginname":"gooking","avatar_url":"https://avatars1.githubusercontent.com/u/7286469?v=4&s=120"}},{"id":"5a5ef4ea9d371d4a059eeb89","author_id":"59c475acd7cbefc5119645f7","tab":"ask","content":"<div class=\"markdown-text\"><p>微信小程序可以实现调用外部app应用吗？</p>\n<p>来自酷炫的 <a href=\"https://github.com/TakWolf/CNode-Material-Design\">CNodeMD</a></p>\n</div>","title":"微信小程序可以实现调用外部app应用吗？","last_reply_at":"2018-01-18T08:28:59.252Z","good":false,"top":false,"reply_count":8,"visit_count":267,"create_at":"2018-01-17T07:02:02.129Z","author":{"loginname":"Tmamasay","avatar_url":"https://avatars1.githubusercontent.com/u/31384364?v=4&s=120"}},{"id":"5a5da79f9d371d4a059eeb1c","author_id":"58628449e8013c6b392b0bd0","tab":"ask","content":"<div class=\"markdown-text\"><p>更改接触Nodejs的时候一直用callback搭配第三方async模块，感觉稳定可靠。后来就一直用promise感觉写的比callback优雅一些，而且流程清楚一些并且promise.all等方法也可以代替之前的async模块解决流程问题。最近接触async/await 感觉挺方便代码也更清晰。同事有用yield配合co的，有用promise的，请问大家都用什么方式解决异步流程问题呢？ 各有什么优势和劣势吗？</p>\n</div>","title":"关于异步流程控制 callback, promise, yield, async&await","last_reply_at":"2018-01-18T08:26:00.924Z","good":false,"top":false,"reply_count":14,"visit_count":407,"create_at":"2018-01-16T07:19:59.643Z","author":{"loginname":"ouyangxuanyun","avatar_url":"https://avatars3.githubusercontent.com/u/10010617?v=4&s=120"}},{"id":"5a604e449d371d4a059eebef","author_id":"57c6959e92fad7e46b4169ab","tab":"ask","content":"<div class=\"markdown-text\"><p>我目前在使用Koa 1.0，自己做了一些简单的封装，最近项目上线后发现内存一直在上升，没有下降，怀疑有内存泄漏，随之进行了一次排查，经过反复的断点测试之后目前初步怀疑是数据库模块产生的问题，最后定位到这段代码</p>\n<pre class=\"prettyprint language-javascript\"><code>ActiveQuery.prototype.afterQueryRecord = function(datas, one){\n\tvar self = this;\n\tif( this.AR.related &amp;&amp; datas.length &gt; 0 ){\n\t\tconsole.log(&#x27;beginning search related : &#x27; + self.id);\n\t\tfor( k in self.AR.related ){\n\t\t\tvar query = self.AR.related[k];\n\t\t\tif( query.relate_status &amp;&amp; query.relate_status == &#x27;pending&#x27; ){\n\t\t\t\tself.pending.push(k);\n\t\t\t}\n\t\t}\n\t\tif( self.pending.length == 0 ){\n\t\t\treturn self.getQueryRecord(datas, one)\n\t\t}\n\t\treturn self.findRelationData(datas, one);\n\t}else{\n\t\treturn this.getQueryRecord(datas, one);\n\t}\n};\nActiveQuery.prototype.findRelationData = function(datas, one){\n\tvar self = this;\n\treturn new Promise(function(resolve, reject){\n\t\tif( self.pending.length &lt;= 0 ){\n\t\t\tresolve(self.getQueryRecord(datas, one));\n\t\t}else{\n\t\t\tvar name = self.pending[0];\n\t\t\tvar related = self.AR.related[name];\n\t\t\trelated.query.findRelation(datas).then(function(rows){\n\t\t\t\tconsole.log(&#x27;finded relation &#x27; + related.name);\n\t\t\t\tself.AR._related[name] = rows;\n\t\t\t\tself.pending.splice(0, 1);\n\t\t\t\tresolve(self.findRelationData(datas, one));\n\t\t\t});\n\t\t}\n\t});\n};\nActiveQuery.prototype.getQueryRecord = function(datas, one){\n\tif( one ){\n\t\tdatas = datas[0] ? datas[0] : {};\n\t}\n\tvar attributes = clone(datas);\n\n\tfunction QueryRecord(){\n\t};\n\tQueryRecord.prototype = clone(Object.getPrototypeOf(this.AR));\n\tQueryRecord.prototype._attributes = attributes;\n\tif( this.options.security ){\n\t\tdatas = this.securityDatas(datas);\n\t}\n\tQueryRecord.prototype._datas = datas;\n\tQueryRecord.prototype.setting = this.AR.setting;\n\tQueryRecord.prototype.tableName = this.AR.tableName;\n\tQueryRecord.prototype.one = one;\n\tQueryRecord.prototype.isSecurity = this.options.security ? 1 : 0;\n\tQueryRecord.prototype.toString = function(){\n\t\treturn &#x27;[QueryRecord Object]&#x27;;\n\t};\n\tvar record = new QueryRecord();\n\tif( one ){\n\t\tif( datas ){\n\t\t\tfor( k in datas ){\n\t\t\t\trecord[k] = datas[k];\n\t\t\t}\n\t\t}\n\t}else{\n\t\tfor( var i = 0; i &lt; datas.length; i++ ){\n\t\t\trecord[i] = datas[i];\n\t\t}\n\t}\n\tvar result = record;\n\tif( this.options.asArray ){\n\t\tresult = record.parsed().toArray();\n\t}\n\treturn result;\n\t&#x2F;&#x2F; return this.options.asArray ? record.toArray() : record;\n};\n\n</code></pre><p>self.AR.related里有预设好的其他表的类\n这段代码是在执行完mysql query后根据related去查找关联关系，然后绑定到当前的类中，想咨询一下各位大神请问这样的话会不会导致内存泄漏，原理是什么，非常感谢</p>\n</div>","title":"咨询一个关于js中内存泄漏的问题","last_reply_at":"2018-01-18T07:35:32.313Z","good":false,"top":false,"reply_count":0,"visit_count":111,"create_at":"2018-01-18T07:35:32.313Z","author":{"loginname":"DerekYeung","avatar_url":"https://avatars1.githubusercontent.com/u/6436013?v=4&s=120"}},{"id":"5a604a5c9d371d4a059eebee","author_id":"54eec259b266136b3949b1e0","tab":"share","content":"<div class=\"markdown-text\"><h1>微信运动数据抓取发布第4版啦！！（2018.1.15）</h1>\n<h1>wxSportCrawler V4</h1>\n<p>一套抓取微信运动真实数据、并将微信运动数据用于活动/场景的程序</p>\n<p>关键字：微信运动、微信步数、运动步数、wechat sport、wechat step、微信硬件</p>\n<p>Demo：\n<a href=\"http://wxsportdemo.grplpl.com/\">http://wxsportdemo.grplpl.com/</a></p>\n<h3>最近更新：</h3>\n<p>一、欢天喜地的V4版本发布啦，API支持<strong>脱离微信公众平台的纯H5调用！</strong> 本Demo即为纯H5的演示。还有大量示例代码可以下载试用。</p>\n<p>二、我们开放小心心啦！朋友们在微信运动里给你点的赞，也能显示在这里了！</p>\n<h3>本API比好色派等官方API最大的优点在于：</h3>\n<p>1、可以脱离微信公众号等微信体系运行，自成一体。</p>\n<p>2、主动抓取所有用户的数据。而官方的只能获取登录了公众号的用户的数据。例如一个实时步数排行榜，官方的就很不准确。</p>\n<p>3、有另一维度的社交数据 —— 微信运动点赞数。</p>\n<p>4、可以方便的和公众平台、小程序、Android和iOS的APP等集成。</p>\n<h3>有关纯H5调用</h3>\n<p>您可以留心注意到，打开本页面的过程中并没有弹出微信公众平台的授权提示，但是也能正常获取您的昵称、头像、步数信息和排行榜了，说明本API已经支持纯H5的调用，脱离微信公众号了。</p>\n<p>这个特性将帮助开发者：</p>\n<p>1、快速开发出微信运动相关的程序。更多的示例代码请在“帮助”下获取和下载。</p>\n<p>2、不再需要架设和维护服务器和VPS等，只需要一个HTML页面即可完成一个项目。</p>\n<p>3、不再需要开发后端程序，只需要一个HTML页面即可完成一个项目。</p>\n<p>4、脱离微信公众号，保障您的APP的稳定和可控。</p>\n<h3>商务合作</h3>\n<p>这里已经实现了一个可用的API，可提供有限的试用。</p>\n<p>具体请联系我，QQ 14707685，注明“微信运动数据”。</p>\n<p>请关注这个项目，<a href=\"https://github.com/klausgao/wxSportCrawler/\">https://github.com/klausgao/wxSportCrawler/</a></p>\n<h3>微信扫码体验</h3>\n<p><img src=\"http://www.grplpl.com/adimages/7.jpg\" alt></p>\n<h3>部分截图</h3>\n<p><img src=\"http://www.grplpl.com/adimages/1.gif\" alt>\n<img src=\"http://www.grplpl.com/adimages/2.gif\" alt>\n<img src=\"http://www.grplpl.com/adimages/3.gif\" alt>\n<img src=\"http://www.grplpl.com/adimages/4.gif\" alt>\n<img src=\"http://www.grplpl.com/adimages/5.gif\" alt>\n<img src=\"http://www.grplpl.com/adimages/6.gif\" alt></p>\n</div>","title":"微信运动数据抓取发布第4版啦！！（2018.1.15）","last_reply_at":"2018-01-18T07:18:52.274Z","good":false,"top":false,"reply_count":0,"visit_count":101,"create_at":"2018-01-18T07:18:52.274Z","author":{"loginname":"klausgao","avatar_url":"https://avatars2.githubusercontent.com/u/11207273?v=4&s=120"}},{"id":"59142d12ba8670562a40ef4d","author_id":"5913f844ba8670562a40ef37","tab":"share","content":"<div class=\"markdown-text\"><p>分享一下今天做的一次实验！\n问题重现:打开浏览器执行以下代码</p>\n<pre class=\"prettyprint language-js\"><code>var a = {b:{c:1}};\nconsole.log(a);\na.b.c = 2;\n</code></pre><p>控制台看到打印出来的是什么？{b:{c:2}}对吗？由此你得出console.log应该是异步的结果。我能告诉你眼见不一定为实么？你所看到的是错误的！拿同样的代码放到node环境下跑你就会发现打印出的是{b:{c:1}}。\n是不是感觉很无奈？同一个V8引擎，执行结果最后居然不一样！\n事实上，执行结果是一样的，只不过你看到的不一样罢了！原因就出在浏览器控制台所见不一定为实。\n尝试把打印的代码换一下，改为console.log(a.b.c)你会发现这次是跟node下一致了。我也不想在此延伸浏览器控制台的问题了，实际上相当于一种懒加载，这也是为什么你可以在控制台无限查看Object的prototype了。\n回到问题本身，console.log究竟是同步还是异步？我觉得console.log应该和alert一样是同步的，会阻塞线程执行。丢一个问题这里：</p>\n<pre class=\"prettyprint language-js\"><code>function test() {\nconsole.log(&#x27;a&#x27;); &#x2F;&#x2F; 为什么加上console.log之后，执行不会报Maximum call stack size exceeded\ntest();\n}\ntest();\n</code></pre></div>","title":"console.log是同步还是异步？眼见不一定为实","last_reply_at":"2018-01-18T06:49:05.222Z","good":false,"top":false,"reply_count":9,"visit_count":2158,"create_at":"2017-05-11T09:21:22.216Z","author":{"loginname":"Telanx","avatar_url":"https://avatars0.githubusercontent.com/u/3286367?v=4&s=120"}},{"id":"5a3b5b3cd1536726354b7fc7","author_id":"5a2a3b849807389a1809f224","tab":"share","content":"<div class=\"markdown-text\"><h3>github地址: <a href=\"https://github.com/ifredom/node-blog\">https://github.com/ifredom/node-blog</a></h3>\n<p>非常适合初学者练习的一个完整项目。\n特点：\n0 贴心的中文注释\n1 用nodemon，修改文件内容后，自动重启服务器，便于开发。\n2 express框架控制路由，设计项目结构\n3 mongodb数据库的增,删,改,查操作\n4 页面使用bootstrap制作，有点响应式.</p>\n<p><img src=\"//dn-cnode.qbox.me/FpuiOu82kUUDZb9gViCi7ttrvMRb\" alt=\"1.png\"></p>\n</div>","title":"分享一个node制作的个人博客","last_reply_at":"2018-01-18T06:21:32.689Z","good":false,"top":false,"reply_count":6,"visit_count":903,"create_at":"2017-12-21T06:57:00.844Z","author":{"loginname":"ifredom","avatar_url":"https://avatars2.githubusercontent.com/u/13759936?v=4&s=120"}},{"id":"5a5f20d1afa0a121784a8cc8","author_id":"57d216e13d3520a5387c2b53","tab":"ask","content":"<div class=\"markdown-text\"><p>RT</p>\n</div>","title":"用nodejs做游戏服务器和网站服务器有什么要注意的。有什么区别","last_reply_at":"2018-01-18T06:10:29.078Z","good":false,"top":false,"reply_count":7,"visit_count":387,"create_at":"2018-01-17T10:09:21.995Z","author":{"loginname":"a69694510","avatar_url":"https://avatars1.githubusercontent.com/u/20507053?v=4&s=120"}},{"id":"5a6009fe9d371d4a059eebd1","author_id":"58a654e75b904b25651b3677","tab":"ask","content":"<div class=\"markdown-text\"><p>rt</p>\n</div>","title":"请问express中i18n大家都怎么搞","last_reply_at":"2018-01-18T05:51:35.141Z","good":false,"top":false,"reply_count":1,"visit_count":127,"create_at":"2018-01-18T02:44:14.579Z","author":{"loginname":"shuaishenk","avatar_url":"https://avatars3.githubusercontent.com/u/3381855?v=4&s=120"}},{"id":"5a600900afa0a121784a8cff","author_id":"5a5d75459288dc8153287e58","tab":"ask","content":"<div class=\"markdown-text\"><p><img src=\"//dn-cnode.qbox.me/FiWRVbWlSGjbSct-R7AQfY5RGsNX\" alt=\"1.jpg\">\n平常内存是这样的。</p>\n<p><strong>然后测试每一秒 100个人请求首页</strong></p>\n<pre class=\"prettyprint language-javascript\"><code>const request = require(&#x27;request&#x27;);\nsetInterval(() =&gt; {\n    for (let i = 0; i &lt; 100; i++) {\n        request(&#x27;http:&#x2F;&#x2F;我的网址首页.com&#x27;, (err, res, body) =&gt; {\n            if (!err &amp;&amp; res.statusCode == 200) {\n                console.log(1)\n            } else {\n                console.log(‘n’)\n            }\n        })\n    }\n\n}, 1000)\n</code></pre><p>然后变这样了。。\n<img src=\"//dn-cnode.qbox.me/FrqcP7lp_St-iO8fj0ZgKrqbJIfg\" alt=\"2.jpg\"></p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;*首页路由如下。。*&#x2F;\nroute.get(&#x27;&#x2F;&#x27;, (req, res) =&gt; {\n    let pageInfo = req.query\n    let searchW = { category: &#x27;article&#x27; }\n    let seo_title = pageInfo.search ? pageInfo.search + &quot;_&quot; : &#x27;&#x27;;\n    let seo_tag = pageInfo.tag ? pageInfo.tag + &quot;_&quot; : &#x27;&#x27;;\n    pageInfo.page = pageInfo.page &amp;&amp; parseInt(pageInfo.page) &gt;= 1 &amp;&amp; parseInt(pageInfo.page) &lt;= 200 ? pageInfo.page : 1\n    let seo_page = pageInfo.page &gt; 1 ? &#96;第${pageInfo.page}页_&#96; : &#x27;&#x27;;\n    let shownum = pageInfo.shownum &amp;&amp; pageInfo.shownum &lt; 50 ? parseInt(pageInfo.shownum) : 30;\n    if (pageInfo.search) {\n        searchW.title = new RegExp(&#96;.*${pageInfo.search}.*&#96;, &#x27;i&#x27;)\n    }\n    if (pageInfo.tag) {\n        searchW.tags = new RegExp(pageInfo.tag, &#x27;i&#x27;)\n    };\n\n    (async() =&gt; {\n        try {\n            let [count, article] = await Promise.all([\n                db.articleModel.count(searchW).exec(),\n                db.articleModel.find(searchW, { content: 0 })\n                .skip(pageInfo.page * shownum - shownum)\n                .limit(shownum).sort({ recommend: -1, _id: -1 })\n                .exec()\n            ])\n            let allPage = Math.ceil(count &#x2F; shownum)\n            res.render(&#x27;index&#x27;, {\n                data: article,\n                page: allPage,\n                headInfo: {\n                    title: seo_tag + seo_page + config_seo.index.title,\n                    keywords: config_seo.index.keywords,\n                    description: config_seo.index.description\n                }\n            })\n        } catch (e) {\n            res.render(&#x27;err&#x27;)\n        }\n\n    })()\n\n})\n</code></pre><p>有时候访问页面就\n<img src=\"//dn-cnode.qbox.me/Fm5JxJE5VyFs_iQS7iAv2SAf6heV\" alt=\"3.jpg\">\n还是我的 服务器是 配置是\nCPU： 1核    内存：1 GB (I/O优化) 1Mbps</p>\n</div>","title":"如何解决访问稍微一多 内存就暴涨！！","last_reply_at":"2018-01-18T05:49:11.853Z","good":false,"top":false,"reply_count":7,"visit_count":236,"create_at":"2018-01-18T02:40:00.795Z","author":{"loginname":"zhubenjie","avatar_url":"https://avatars3.githubusercontent.com/u/21832438?v=4&s=120"}},{"id":"5a603506afa0a121784a8d19","author_id":"5a2f5f95d92f2f5b185acdb3","tab":"ask","content":"<div class=\"markdown-text\"><p>后端返回Buffer的二进制数据，前端接收到就变了数据格式？ 是编码问题?还是什么原因？\n图1：node输出的<img src=\"//dn-cnode.qbox.me/Fq0DWo_ufiGOLD6oTKkpcu3HNcgc\" alt=\"1516254279(1).png\">\n图2：客户端输出的。<img src=\"//dn-cnode.qbox.me/FkC3f9CpHd-LBvFKzzWJi-bMncXf\" alt=\"1516254253(1).png\">\nnode是返回Buffer类型的给前端了！！！求大神们解答?</p>\n</div>","title":"后端返回Buffer的二进制数据，前端接收到就变了数据格式？","last_reply_at":"2018-01-18T05:47:50.310Z","good":false,"top":false,"reply_count":0,"visit_count":114,"create_at":"2018-01-18T05:47:50.310Z","author":{"loginname":"335296558","avatar_url":"https://avatars2.githubusercontent.com/u/16714578?v=4&s=120"}},{"id":"5a5312e0afa0a121784a8a43","author_id":"5a2f5f95d92f2f5b185acdb3","tab":"ask","content":"<div class=\"markdown-text\"><p>谁能解释以下json对象的意思吗？插入数据库返回的！我要判断成功失败 要判断哪个json对象呢？\n<img src=\"//dn-cnode.qbox.me/Fr3DIj8QGzVsUUQaQA_K7DEXHSac\" alt=\"1515393336(1).png\">  在线等？</p>\n</div>","title":"谁能解释下以下json对象的意思吗？","last_reply_at":"2018-01-18T05:40:44.334Z","good":false,"top":false,"reply_count":7,"visit_count":709,"create_at":"2018-01-08T06:42:40.477Z","author":{"loginname":"335296558","avatar_url":"https://avatars2.githubusercontent.com/u/16714578?v=4&s=120"}},{"id":"5a5fe71f9d371d4a059eebbd","author_id":"56a574f5f03253594b7fb6b8","tab":"ask","content":"<div class=\"markdown-text\"><p><a href=\"https://github.com/cnpm/cnpmjs.org/issues/1287\">https://github.com/cnpm/cnpmjs.org/issues/1287</a>\nnodejs文档镜像已经很长时间404了，页面也不知道可以通知谁修复下</p>\n</div>","title":"现在淘宝npm镜像有人专门维护吗","last_reply_at":"2018-01-18T04:31:22.153Z","good":false,"top":false,"reply_count":3,"visit_count":262,"create_at":"2018-01-18T00:15:27.633Z","author":{"loginname":"kimown","avatar_url":"https://avatars2.githubusercontent.com/u/7932380?v=4&s=120"}},{"id":"5a5f7268a3692d014f4f1557","author_id":"594fe00f642874f845d9fe16","tab":"ask","content":"<div class=\"markdown-text\"><p>尝试在egg中使用自定义启动一组自己写的cluster, 但是却启动不了，cluster的变量也很奇怪，请教一下各位大神</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; 自定义启动 app.js\nmodule.exports = app =&gt; {\n  app.beforeStart(async () =&gt; {\n    app.cluster = require(&#x27;.&#x2F;cluster&#x2F;master&#x27;);\n  });\n};\n</code></pre><pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; .&#x2F;cluster&#x2F;master.js\nconst cluster = require(&#x27;cluster&#x27;);\nconsole.log(&#x27;NODE_UNIQUE_ID&#x27; in process.env); &#x2F;&#x2F; false\nconsole.log(cluster.isMaster); &#x2F;&#x2F;false\n...\nmodule.exports = cluster;\n</code></pre><p>最奇怪的就是从app.js 调用执行master.js 后，尽管NODE_UNIQUE_ID是undefined，但cluster.isMaster却是false？？？实在想不通。因为isMaster是false, 后面的setupMaster()等操作也无法进行。</p>\n</div>","title":"在egg中启动自定义cluster失败","last_reply_at":"2018-01-18T04:12:40.681Z","good":false,"top":false,"reply_count":8,"visit_count":123,"create_at":"2018-01-17T15:57:28.997Z","author":{"loginname":"samcsf","avatar_url":"https://avatars0.githubusercontent.com/u/16800119?v=4&s=120"}},{"id":"5a601b46afa0a121784a8d0c","author_id":"58e261ed27d4e130201065f7","tab":"ask","content":"<div class=\"markdown-text\"><h2>想在帖子列表中插入作者头像</h2>\n<p>结果发现列表中作者是<code>author_id</code>, 个人信息是<code>username</code>,\n这两个api有什么关联的办法吗？</p>\n</div>","title":"cnode客户端一个小问题","last_reply_at":"2018-01-18T03:57:58.068Z","good":false,"top":false,"reply_count":0,"visit_count":92,"create_at":"2018-01-18T03:57:58.068Z","author":{"loginname":"phpsmarter","avatar_url":"https://avatars3.githubusercontent.com/u/10001670?v=4&s=120"}},{"id":"5a601900ce45d440451460f7","author_id":"57e9df6856898f231a526fa4","tab":"share","content":"<div class=\"markdown-text\"><h1>vue-table-pagination</h1>\n<p>vue2封装的table联动组件</p>\n<p><a href=\"https://www.npmjs.org/package/vue-table-pagination\"><img src=\"https://nodei.co/npm/vue-table-pagination.png?compact=true\" alt=\"NPM\"></a></p>\n<p><a href=\"https://badge.fury.io/js/vue-table-pagination\"><img src=\"https://badge.fury.io/js/vue-table-pagination.svg\" alt=\"npm version\"></a>\n<a href=\"https://www.travis-ci.org/jackieli123723/vue-table-pagination\"><img src=\"https://www.travis-ci.org/jackieli123723/vue-table-pagination.svg?branch=master\" alt=\"Build Status\"></a>\n<a href=\"https://coveralls.io/github/jackieli123723/vue-table-pagination?branch=master\"><img src=\"https://coveralls.io/repos/github/jackieli123723/vue-table-pagination/badge.svg?branch=master\" alt=\"Coverage Status\"></a>\n<a href=\"https://www.npmjs.com/package/vue-table-pagination\"><img src=\"https://img.shields.io/npm/dm/vue-table-pagination.svg\" alt=\"npm Download\"></a>\n<a href=\"https://www.npmjs.com/package/vue-table-pagination\"><img src=\"http://img.badgesize.io/https://unpkg.com/vue-table-pagination?compression=gzip\" alt=\"gzip\"></a>\n<a href=\"https://github.com/facebook/jest\"><img src=\"https://img.shields.io/badge/tested_with-jest-99424f.svg\" alt=\"tested with jest\"></a></p>\n<h2>Live Demo</h2>\n<p><a href=\"http://page.lilidong.cn/#/\">vue-table-pagination-demo Site</a></p>\n<h2>Install with npm</h2>\n<pre class=\"prettyprint\"><code>Installing\n\nnpm install --save vue-table-pagination\n\nImport\n\nimport Vue from &#x27;vue&#x27;;\nimport VueTablePagination from &#x27;vue-table-pagination&#x27;;\nVue.use(VueTablePagination);\n</code></pre><h1>西门互联分页组件</h1>\n<p>可自定义配置和分页可fork自行修改</p>\n<pre class=\"prettyprint\"><code>&lt;vue-table-pagination\n                    @gmChangePageButton=&quot;gmChangePageButton&quot;\n                    @gmChagePageSize=&quot;gmChagePageSize&quot;\n                    :gmCurrentPage=&quot;page&quot;\n                    :gmTotalPage=&quot;totalPage&quot;\n                    :gmCanJump=&quot;true&quot;\n                    :gmCanChoose=&quot;true&quot;\n                    :gmTableLists=&quot;gmTableLists&quot;\n                    :gmTableThLists=&quot;gmTableThLists&quot;\n                    :gmIsIndex=&quot;true&quot;\n                    @gmPerEmitClick=&quot;gmPerEmitClick&quot;\n                    :gmTableWidth=&quot;0&quot;\n                    :gmTimeStampType=&quot;63&quot;\n            &gt;&lt;&#x2F;vue-table-pagination&gt;\ngmChangePageButton -- 按钮改变分页\ngmChagePageSize --每页显示多少条\npage -- 当前高亮锚点\ntotalPage -- 总页数\ngmCanJump --是否跳转\ngmCanChoose -- 是否改变分页条数\ngmTableLists --tbody数据\ngmTableThLists --theader数据\ngmIsIndex --开启索引\ngmPerEmitClick --table中的按钮操作\ngmTableWidth --table宽度\ngmTimeStampType --时间参数\n</code></pre><h2>效果图截图</h2>\n<p><img src alt=\"vue2封装的table联动组件\">\n<img src alt=\"vue2封装的table联动组件配色\"></p>\n<h2>演示test.vue</h2>\n<pre class=\"prettyprint\"><code>&lt;template&gt;\n\n    &lt;div class=&quot;page-view&quot;&gt;\n        &lt;div class=&quot;page-content&quot;&gt;\n          &lt;!-- 通用table组件 --&gt;\n          &lt;!--用法 --&gt;\n          &lt;vue-table-pagination\n                  @gmChangePageButton=&quot;gmChangePageButton&quot;\n                  @gmChagePageSize=&quot;gmChagePageSize&quot;\n                  :gmCurrentPage=&quot;page&quot;\n                  :gmTotalPage=&quot;totalPage&quot;\n                  :gmCanJump=&quot;true&quot;\n                  :gmCanChoose=&quot;true&quot;\n                  :gmTableLists=&quot;gmTableLists&quot;\n                  :gmTableThLists=&quot;gmTableThLists&quot;\n                  :gmIsIndex=&quot;true&quot;\n                  @gmPerEmitClick=&quot;gmPerEmitClick&quot;\n                  :gmTableWidth=&quot;0&quot;\n                  :gmTimeStampType=&quot;63&quot;\n          &gt;&lt;&#x2F;vue-table-pagination&gt;\n        &lt;&#x2F;div&gt;\n      &lt;&#x2F;div&gt;\n\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\n\n  export default {\n    name: &#x27;test&#x27;,\n    data(){\n      return {\n          page:1,\n          pageSize:10,\n          totalPage:100,\n          &#x2F;&#x2F;修改为value对象下面值取\n          gmTableLists:[\n              {\n                &quot;game_uuid&quot;: {\n                  &quot;value&quot;: 14\n                },\n                &quot;title&quot;: {\n                  &quot;value&quot;: &quot;标题1&quot;\n                },\n                &quot;content&quot;: {\n                  &quot;value&quot;: &quot;这是标题1的所有内容内容这是标题1的所有内容内容&quot;\n                },\n                &quot;attachment&quot;: {\n                  &quot;value&quot;: [\n                    {\n                      &quot;props&quot;: &quot;晶能id&quot;,\n                      &quot;number&quot;: &quot;10&quot;\n                    }, {\n                      &quot;props&quot;: &quot;皮肤id&quot;,\n                      &quot;number&quot;: &quot;10&quot;\n                    }\n                  ]\n                },\n                &quot;receiver&quot;: {\n                  &quot;value&quot;: [&quot;张三&quot;, &quot;李四&quot;, &quot;王麻子&quot;, &quot;小红&quot;]\n                },\n                &quot;sendtime&quot;: {\n                  &quot;value&quot;: 1515772800\n                },\n                &quot;create_user&quot;: {\n                  &quot;value&quot;: &quot;超级管理员1&quot;\n                },\n                &quot;create_time&quot;: {\n                  &quot;value&quot;: 1515828493\n                },\n                &quot;update_user&quot;: {\n                  &quot;value&quot;: &quot;admin&quot;\n                },\n                &quot;update_time&quot;: {\n                  &quot;value&quot;: &#x27;1515828493&#x27;\n                },\n                &quot;operate&quot;: {\n                  &quot;value&quot;: [\n                    {\n                      &quot;game_uuid&quot;: 14,\n                      &quot;action&quot;: &quot;pk_id&quot;\n                    }, {\n                      &quot;button_name&quot;: &quot;编辑&quot;,\n                      &quot;action&quot;: &quot;edit&quot;\n                    }, {\n                      &quot;button_name&quot;: &quot;删除&quot;,\n                      &quot;action&quot;: &quot;delte&quot;\n                    }\n                  ]\n                }\n              },\n              {\n                &quot;game_uuid&quot;: {\n                  &quot;value&quot;: 15\n                },\n                &quot;title&quot;: {\n                  &quot;value&quot;: &quot;标题2&quot;\n                },\n                &quot;content&quot;: {\n                  &quot;value&quot;: &quot;这是标题2的所有内容内容这是标题1的所有内容内容&quot;\n                },\n                &quot;attachment&quot;: {\n                  &quot;value&quot;: [{\n                    &quot;props&quot;: &quot;晶能id&quot;,\n                    &quot;number&quot;: &quot;11&quot;\n                  }, {\n                    &quot;props&quot;: &quot;皮肤id&quot;,\n                    &quot;number&quot;: &quot;12&quot;\n                  }]\n                },\n                &quot;receiver&quot;: {\n                  &quot;value&quot;: [&quot;小米&quot;, &quot;小明&quot;]\n                },\n                &quot;sendtime&quot;: {\n                  &quot;value&quot;: 1515772800\n                },\n                &quot;create_user&quot;: {\n                  &quot;value&quot;: &quot;超级管理员2&quot;\n                },\n                &quot;create_time&quot;: {\n                  &quot;value&quot;: 1515828093\n                },\n                &quot;update_user&quot;: {\n                  &quot;value&quot;: &quot;jackieli&quot;\n                },\n                &quot;update_time&quot;: {\n                  &quot;value&quot;: &#x27;&#x27;\n                },\n                &quot;operate&quot;: {\n                  &quot;value&quot;: [\n                    {\n                      &quot;game_uuid&quot;: 15,\n                      &quot;action&quot;: &quot;pk_id&quot;\n                    }, {\n                      &quot;button_name&quot;: &quot;编辑&quot;,\n                      &quot;action&quot;: &quot;edit&quot;\n                    }, {\n                      &quot;button_name&quot;: &quot;删除&quot;,\n                      &quot;action&quot;: &quot;delte&quot;\n                    }\n                  ]\n                }\n              }\n          ],\n          &#x2F;&#x2F;接口先获取这个表头字段对应    &quot;fields&quot;:&#x2F;&#x2F;表单字段列表  button 操作\n          &#x2F;&#x2F;然后在获取gmTableLists\n          &#x2F;&#x2F;每个用户看到的字段格式都不一样（权限可设置）\n          gmTableThLists:{\n              &quot;game_uuid&quot;:&quot;流水号&quot;,\n              &quot;title&quot;:&quot;标题&quot;,\n              &quot;content&quot;:&quot;内容预览&quot;,\n              &quot;attachment&quot;:&quot;邮件奖励&quot;,\n              &quot;receiver&quot;:&quot;收件人&#x2F;人数&quot;,\n              &quot;sendtime&quot;:&quot;发送时间&quot;,\n              &quot;create_user&quot;:&quot;创建者&quot;,\n              &quot;create_time&quot;:&quot;创建时间&quot;,\n              &quot;update_user&quot;:&quot;审核人&quot;,\n              &quot;update_time&quot;:&quot;审核时间&quot;\n          }\n      }\n    },\n    methods: {\n      &#x2F;&#x2F;循环事件派发\n      gmPerEmitClick(list,index,type){\n        console.log(&quot;格式化后的当前列数据&quot;,list);\n        let game_uuid = list.game_uuid.value\n        &#x2F;&#x2F;通过this.gmTableLists[index]的数据来判断每列操作的button的事件\n        console.log(&quot;通过index参数获取原始数据的操作当前列&quot;,this.gmTableLists[index])\n        &#x2F;&#x2F; console.log(&quot;商品id:&quot;+id+&quot;---事件:&quot;+type)\n        console.log(&quot;流水号:&quot;+game_uuid+&quot;---对外index:&quot;+index+&quot;--对外事件类型&quot;+type)\n        &#x2F;&#x2F;this.$router.replace(&#x27;&#x2F;&#x27;)\n      },\n      gmChagePageSize(data){\n        this.page = 1\n        this.pageSize = data\n        console.log(data)\n      },\n      &#x2F;&#x2F;分页组件传递事件ajax\n      gmChangePageButton(page){\n         this.page = page\n         console.log(page)\n      }\n    }\n  };\n&lt;&#x2F;script&gt;\n\n&lt;style lang=&quot;css&quot;&gt;\n  #app {\n  font-family: &#x27;Avenir&#x27;, Helvetica, Arial, sans-serif;\n  color: #2c3e50;\n}\n\n* {\n    -webkit-box-sizing: border-box;\n    -moz-box-sizing: border-box;\n    box-sizing: border-box;\n    margin: 0;\n    padding: 0;\n}\n\n\n* &gt; input:-webkit-autofill {\n    -webkit-box-shadow: 0 0 0px 1000px #fff inset !important; &#x2F;*关于解决输入框背景颜色*&#x2F;\n    -webkit-text-fill-color: #000000!important;\n}\nhtml,\nbody {\n    font-family: &quot;Microsoft YaHei&quot;;\n    font-size: 14px;\n    color: rgba(0, 0, 0, 0.85);\n    background: #fff;\n    padding: 0 10px;\n    overflow-x: hidden;\n    -webkit-font-smoothing: antialiased;\n}\n\nol,\nul,\nli {\n    list-style: none;\n}\n\nimg {\n    border: 0 none;\n}\n\na {\n    text-decoration: none;\n}\n\na,\ninput,\ntextarea {\n    outline: none;\n}\n\ninput::-ms-clear,\ninput::-ms-reveal {\n    display: none;\n}\n\ntable {\n    border-collapse: collapse;\n    border-spacing: 0;\n}\n\ncaption,\nth,\ntd {\n    text-align: left;\n    font-weight: normal;\n    vertical-align: middle;\n}\n\n.clearfix {\n    *zoom: 1;\n}\n\n.clearfix:after {\n    clear: both;\n    content: &#x27;&#x27;;\n    display: block;\n    height: 0;\n    visibility: hidden;\n}\n\n.hide {\n    display: none !important;\n}\n\n.show {\n    display: block;\n}\n\n.fl {\n    float: left;\n}\n\n.fr {\n    float: right\n}\n&lt;&#x2F;style&gt;\n\n</code></pre></div>","title":"vue2封装的table联动组件","last_reply_at":"2018-01-18T03:48:16.795Z","good":false,"top":false,"reply_count":0,"visit_count":102,"create_at":"2018-01-18T03:48:16.795Z","author":{"loginname":"jackieli123723","avatar_url":"https://avatars1.githubusercontent.com/u/10346511?v=4&s=120"}},{"id":"5a5f05549288dc8153287ee6","author_id":"5a5efb529288dc8153287edc","tab":"ask","content":"<div class=\"markdown-text\"><p>萌新按照<a href=\"https://tech.meituan.com/promise-insight.html\">剖析 Promise 之基础篇</a>学习实现了下promise，但是发现有一个很大的问题，那就是then在promise已改变状态下注册方法，该注册方法不会异步执行，变成了立即执行，请教下各位老哥，代码该如何修改（handle方法），还是说其他方法有问题，亦或是萌新我的理解有误。。。</p>\n<p>代码如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>const PENDING = 0;\nconst FULFILLED = 1;\nconst REJECTED = 2;\n\nfunction SimplePromise(fn) {\n  let state = PENDING;\n  let value = null;\n  let deferreds = [];\n\n  this.then = function (onFulfilled, onRejected) {\n    return new SimplePromise (function (resolve, reject) {\n      &#x2F;&#x2F; 当promise某一结果状态处理函数完成后，应将bridge promise状态改变，并向其传递结果值\n      handle({\n        onFulfilled: onFulfilled || null,\n        onRejected: onRejected || null,\n        resolve: resolve,\n        reject: reject\n      });\n    });\n  }\n\n  function handle(deferred) {\n    if (state === PENDING) {\n      deferreds.push(deferred);\n      return;\n    }\n\n    let cb = state === FULFILLED ? deferred.onFulfilled : deferred.onRejected;\n    &#x2F;&#x2F; 当前promise一结果状态未注册相应处理函数，则将状态传递\n    if (cb === null) {\n      cb = state === FULFILLED ? deferred.resolve : deferred.reject;\n      cb(value);\n      return;\n    }\n\n    try {\n      let ret = cb(value);\n      deferred.resolve(ret);\n    } catch (e) {\n      deferred.reject(e);\n    }\n  }\n\n  function finale() {\n    setTimeout(function () {\n      deferreds.forEach(deferred =&gt; handle(deferred));\n    }, 0);\n  }\n\n  function resolve(newValue) {\n    &#x2F;&#x2F; 用于处理方法返回的结果是promise\n    if (newValue &amp;&amp; (typeof newValue === &#x27;object&#x27; || typeof newValue === &#x27;function&#x27;)) {\n      let then = newValue.then;\n      if (typeof then === &#x27;function&#x27;) {\n        &#x2F;&#x2F; bridge promise为了获取方法中返回的promise的结果值，向它注册异步操作后的处理函数\n        then.call(newValue, resolve, reject);\n        return;\n      }\n    }\n\n    state = FULFILLED;\n    value = newValue;\n    finale();\n  }\n\n  function reject(reason) {\n    state = REJECTED;\n    value = reson;\n    finale();\n  }\n\n  function doResolve(fn, resolve, reject) {\n    let done = false;\n    try {\n      fn(function (value) {\n        if (done) return;\n        done = true;\n        resolve(value);\n      }, function (reson) {\n        if (done) return;\n        done = true;\n        reject(reson);\n      })\n    } catch (e) {\n      if (done) return;\n      done = true;\n      reject(e);\n    }\n  }\n\n  doResolve(fn, resolve, reject);\n}\n\n</code></pre><p>比如在这种情况下会出现问题：\n按规范不是应该先打印aaa吗？</p>\n<pre class=\"prettyprint language-javascript\"><code>\nfunction getUserId() {\n  return new SimplePromise(function (resolve) {\n    resolve(9876);   \n  });\n}\n\ngetUserId()\n  .then(function (mobile) {\n      console.log(&#x27;do sth with&#x27;, mobile);\n      return &#x27;ccc&#x27;;\n  })\n  .then(console.log);\n\nconsole.log(&#x27;aaa&#x27;);\n\n</code></pre><p>打印结果：</p>\n<pre class=\"prettyprint language-javascript\"><code>\ndo sth with 9876\nccc\naaa\n\n</code></pre></div>","title":"promise实现求助","last_reply_at":"2018-01-18T03:32:57.223Z","good":false,"top":false,"reply_count":3,"visit_count":250,"create_at":"2018-01-17T08:12:04.916Z","author":{"loginname":"huhu2356","avatar_url":"https://avatars1.githubusercontent.com/u/19721601?v=4&s=120"}},{"id":"593bb3769db8df0a1780f8eb","author_id":"593bb31c9db8df0a1780f8ea","tab":"ask","content":"<div class=\"markdown-text\"><p>visual studio code 怎么样调试egg.js搭建的项目啊？\n应该怎么配置？\n下了断点 并不会断下啊？\n知道的说一下  谢谢。</p>\n</div>","title":"visual studio code 调试 egg.js搭建的项目的问题？","last_reply_at":"2018-01-18T03:23:47.634Z","good":false,"top":false,"reply_count":14,"visit_count":1839,"create_at":"2017-06-10T08:53:10.057Z","author":{"loginname":"woyunyun4le","avatar_url":"https://avatars1.githubusercontent.com/u/16350880?v=3&s=120"}},{"id":"5640b80d3a6aa72c5e0030b6","author_id":"51cfccdd73c638f3708c58d8","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p>阅读本文前，期待您对promise和ES6(ECMA2015)有所了解，会更容易理解。\n本文以体验为主，不会深入说明，结尾有详细的文章引用。</p>\n</blockquote>\n<h2>第一个例子</h2>\n<p>Async/Await应该是目前最简单的异步方案了，首先来看个例子。</p>\n<p>这里我们要实现一个暂停功能，输入N毫秒，则停顿N毫秒后才继续往下执行。</p>\n<pre class=\"prettyprint language-js\"><code>var sleep = function (time) {\n    return new Promise(function (resolve, reject) {\n        setTimeout(function () {\n            resolve();\n        }, time);\n    })\n};\n\nvar start = async function () {\n    &#x2F;&#x2F; 在这里使用起来就像同步代码那样直观\n    console.log(&#x27;start&#x27;);\n    await sleep(3000);\n    console.log(&#x27;end&#x27;);\n};\n\nstart();\n</code></pre><p>控制台先输出<code>start</code>，稍等<code>3秒</code>后，输出了<code>end</code>。</p>\n<h2>基本规则</h2>\n<ol>\n<li>\n<p>async 表示<code>这是一个async函数</code>，<code>await只能用在这个函数里面</code>。</p>\n</li>\n<li>\n<p>await 表示在这里<code>等待promise返回结果</code>了，再继续执行。</p>\n</li>\n<li>\n<p>await 后面跟着的<code>应该是一个promise对象</code>（当然，其他返回值也没关系，只是会立即执行，不过那样就没有意义了…）</p>\n</li>\n</ol>\n<h2>获得返回值</h2>\n<p>await等待的虽然是promise对象，但不必写<code>.then(..)</code>，直接可以得到返回值。</p>\n<pre class=\"prettyprint language-js\"><code>var sleep = function (time) {\n    return new Promise(function (resolve, reject) {\n        setTimeout(function () {\n            &#x2F;&#x2F; 返回 ‘ok’\n            resolve(&#x27;ok&#x27;);\n        }, time);\n    })\n};\n\nvar start = async function () {\n    let result = await sleep(3000);\n    console.log(result); &#x2F;&#x2F; 收到 ‘ok’\n};\n</code></pre><h2>捕捉错误</h2>\n<p>既然<code>.then(..)</code>不用写了，那么<code>.catch(..)</code>也不用写，可以直接用标准的<code>try catch</code>语法捕捉错误。</p>\n<pre class=\"prettyprint language-js\"><code>var sleep = function (time) {\n    return new Promise(function (resolve, reject) {\n        setTimeout(function () {\n            &#x2F;&#x2F; 模拟出错了，返回 ‘error’\n            reject(&#x27;error&#x27;);\n        }, time);\n    })\n};\n\nvar start = async function () {\n    try {\n        console.log(&#x27;start&#x27;);\n        await sleep(3000); &#x2F;&#x2F; 这里得到了一个返回错误\n        \n        &#x2F;&#x2F; 所以以下代码不会被执行了\n        console.log(&#x27;end&#x27;);\n    } catch (err) {\n        console.log(err); &#x2F;&#x2F; 这里捕捉到错误 &#96;error&#96;\n    }\n};\n</code></pre><h2>循环多个await</h2>\n<p>await看起来就像是同步代码，所以可以理所当然的写在<code>for</code>循环里，不必担心以往需要<code>闭包</code>才能解决的问题。</p>\n<pre class=\"prettyprint language-js\"><code>..省略以上代码\n\nvar start = async function () {\n    for (var i = 1; i &lt;= 10; i++) {\n        console.log(&#96;当前是第${i}次等待..&#96;);\n        await sleep(1000);\n    }\n};\n</code></pre><p>值得注意的是，<code>await</code>必须在<code>async函数的上下文中</code>的。</p>\n<pre class=\"prettyprint language-js\"><code>..省略以上代码\n\nlet 一到十 = [1,2,3,4,5,6,7,8,9,10];\n\n&#x2F;&#x2F; 错误示范\n一到十.forEach(function (v) {\n    console.log(&#96;当前是第${v}次等待..&#96;);\n    await sleep(1000); &#x2F;&#x2F; 错误!! await只能在async函数中运行\n});\n\n&#x2F;&#x2F; 正确示范\nfor(var v of 一到十) {\n    console.log(&#96;当前是第${v}次等待..&#96;);\n    await sleep(1000); &#x2F;&#x2F; 正确, for循环的上下文还在async函数中\n}\n</code></pre><h2>第二个例子</h2>\n<p>这个例子是一个小应用，根据电影文件名，自动下载对应的海报。</p>\n<p><img src=\"https://raw.github.com/think2011/ES7-Async-Await-Demo/master/app-demo.gif\" alt></p>\n<p>直接贴出代码，就不说明了。</p>\n<pre class=\"prettyprint language-js\"><code>import fs from &#x27;fs&#x27;;\nimport path from &#x27;path&#x27;;\nimport request from &#x27;request&#x27;;\n\nvar movieDir = __dirname + &#x27;&#x2F;movies&#x27;,\n    exts     = [&#x27;.mkv&#x27;, &#x27;.avi&#x27;, &#x27;.mp4&#x27;, &#x27;.rm&#x27;, &#x27;.rmvb&#x27;, &#x27;.wmv&#x27;];\n\n&#x2F;&#x2F; 读取文件列表\nvar readFiles = function () {\n    return new Promise(function (resolve, reject) {\n        fs.readdir(movieDir, function (err, files) {\n            resolve(files.filter((v) =&gt; exts.includes(path.parse(v).ext)));\n        });\n    });\n};\n\n&#x2F;&#x2F; 获取海报\nvar getPoster = function (movieName) {\n    let url = &#96;https:&#x2F;&#x2F;api.douban.com&#x2F;v2&#x2F;movie&#x2F;search?q=${encodeURI(movieName)}&#96;;\n\n    return new Promise(function (resolve, reject) {\n        request({url: url, json: true}, function (error, response, body) {\n            if (error) return reject(error);\n\n            resolve(body.subjects[0].images.large);\n        })\n    });\n};\n\n&#x2F;&#x2F; 保存海报\nvar savePoster = function (movieName, url) {\n    request.get(url).pipe(fs.createWriteStream(path.join(movieDir, movieName + &#x27;.jpg&#x27;)));\n};\n\n\n(async () =&gt; {\n    let files = await readFiles();\n\n    &#x2F;&#x2F; await只能使用在原生语法\n    for (var file of files) {\n        let name = path.parse(file).name;\n\n        console.log(&#96;正在获取【${name}】的海报&#96;);\n        savePoster(name, await getPoster(name));\n    }\n\n    console.log(&#x27;=== 获取海报完成 ===&#x27;);\n})();\n</code></pre><h2>其他信息</h2>\n<p>微软的Edge浏览器已经率先支持了async/await语法，相信不久之后chrome等浏览器、node.js也会跟进的，超期待！~(≧▽≦)/~</p>\n<h2>一些资料和工具</h2>\n<ul>\n<li><a href=\"https://github.com/think2011/ES7-Async-Await-Demo\">文中讲到的例子的源代码 https://github.com/think2011/ES7-Async-Await-Demo</a></li>\n<li><a href=\"https://babeljs.io/repl/\">方便的在线babel运行环境 https://babeljs.io/repl/</a></li>\n<li><a href=\"http://es6.ruanyifeng.com/#docs/async\">很详细的异步编程教程 http://es6.ruanyifeng.com/#docs/async</a></li>\n<li><a href=\"http://liubin.github.io/promises-book/#introduction\">很详细的promise小书 http://liubin.github.io/promises-book/#introduction</a></li>\n</ul>\n<blockquote>\n<p>本文同时发布在 <a href=\"http://think2011.github.io/2015/11/09/ES7-Async-Await/\">think2011的博客</a> 2015-11-09 22:42</p>\n</blockquote>\n</div>","title":"体验异步的终极解决方案-ES7的Async/Await","last_reply_at":"2018-01-18T03:19:32.804Z","good":true,"top":false,"reply_count":82,"visit_count":140933,"create_at":"2015-11-09T15:13:17.738Z","author":{"loginname":"think2011","avatar_url":"https://avatars1.githubusercontent.com/u/3961388?v=4&s=120"}}]}